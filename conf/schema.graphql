input acceptCircleTermsOfUseInput {
  """Id of the ToU to accept"""
  termsOfUseId: String!

  """Id of the user who accepts"""
  userId: String!
  clientMutationId: String
}

type acceptCircleTermsOfUsePayload {
  viewer: Viewer
  termsOfUse: CircleTermsOfUse
  clientMutationId: String
}

input addCircleInput {
  """The IDs of circles that will be add in an activity"""
  circleIds: [String]!

  """The IDs of the sportunities to update"""
  sportunityIDs: [String]!
  clientMutationId: String
}

input addCircleMemberInput {
  circleId: String!
  userId: String
  pseudo: String
  email: String
  parentId: String
  parentEmail: String
  parentPseudo: String
  clientMutationId: String
}

type addCircleMemberPayload {
  edge: CircleEdge
  viewer: Viewer
  circle: Circle
  clientMutationId: String
}

input addCircleMembersInput {
  """Id of the circle to update"""
  circleId: String!

  """Id of the users to add"""
  users: [String]
  clientMutationId: String
}

type addCircleMembersPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

type addCirclePayload {
  viewer: Viewer
  clientMutationId: String
}

input addMsgInput {
  """The ID of the chat to add the message"""
  chatId: String
  message: MessageInput
  clientMutationId: String
}

type addMsgPayload {
  edge: ChatEdge
  viewer: Viewer
  clientMutationId: String
}

input addMsgSubscriptionInput {
  """The ID of the chats to subscribe to"""
  chatIds: [String]
  clientSubscriptionId: String
}

type addMsgSubscriptionPayload {
  chat: Chat
  edge: ChatEdge
  viewer: Viewer
  clientSubscriptionId: String
}

input addParentMemberInput {
  circleId: String!
  parent1Id: String
  parent1Email: String
  parent2Id: String
  parent2Email: String
  childPseudo: String
  clientMutationId: String
}

type addParentMemberPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input addPendingSecondaryOrganizerInput {
  """The IDs of the sportunities to update"""
  sportunityIDs: [String]!

  """pending organizer input"""
  pendingOrganizer: PendingOrganizerInput!
  clientMutationId: String
}

type addPendingSecondaryOrganizerPayload {
  viewer: Viewer
  clientMutationId: String
}

"""Represents an address input type"""
input AddressInput {
  """The address"""
  address: String!

  """The name of the country"""
  country: String!

  """The name of the city"""
  city: String!
  zip: String
}

"""A physical address"""
type AddressModel {
  """The address"""
  address: String!

  """The ISO ALPHA-2 Code of this country"""
  country: String!

  """The name of the city"""
  city: String!

  """The zip code"""
  zip: String

  """An address position"""
  position: PositionType
}

input addSecondaryOrganizerInput {
  """The IDs of the sportunities to update"""
  sportunityIDs: [String]!

  """Organizer input"""
  organizer: OrganizerInput!
  clientMutationId: String
}

type addSecondaryOrganizerPayload {
  viewer: Viewer
  clientMutationId: String
}

input addSportunityImageInput {
  """The ID of the sportunity to update"""
  sportunityID: String!
  clientMutationId: String
}

type addSportunityImagePayload {
  sportunity: Sportunity
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

"""Represents the global statistics for the application"""
type AdminStatistics {
  """Number of users in the application"""
  userNumber: Int

  """Number of sportunities in the application"""
  sportunityNumber: Int
}

"""Ask Mango Pay to get the amount on current user's wallet"""
type AmountOnWallet {
  """Total amount on the wallet"""
  amountOnWallet: TotalAmountOnWallet

  """Locked amount on the wallet : to pay booked sportunities"""
  lockedAmount: LockedAmountOnWallet
}

"""Answers for members of the cirle"""
input Answers {
  userId: String!
  filledInformation: [Information]
}

input askCarPoolingInput {
  """The ID of the sportunity"""
  sportunityID: String!
  clientMutationId: String
}

type askCarPoolingPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

"""Asked informations for a specific circle"""
type askedInformation {
  """The ID of an object"""
  id: ID!

  """Name of the asked information"""
  name: String

  """Type of the asked information"""
  type: AskedInformationType

  """Tells if this the owner that will fill this field"""
  filledByOwner: Boolean

  """List of possible answers (for custom Type only)"""
  answers: [String]
  form: CircleInformationFormOutput
}

"""Represents a list of asked information for a specific circle"""
input AskedInformation {
  """Id of the asked information (if exsits)"""
  id: String

  """The name of the asked information"""
  name: String!

  """The type of the asked information"""
  type: AskedInformationType!

  """Tells if this is the owner that will fill this information"""
  filledByOwner: Boolean!
}

"""Represents a list of asked information for a specific circle"""
input AskedInformationInput {
  """Id of the asked information (if exsits)"""
  id: String

  """The name of the asked information"""
  name: String!

  """The type of the asked information"""
  type: AskedInformationType!

  """Tells if this is the owner that will fill this information"""
  filledByOwner: Boolean!

  """List of possible answers (for custom Type only)"""
  answers: [String]
}

"""Gives the type of an asked information"""
enum AskedInformationType {
  """String"""
  TEXT

  """Integer"""
  NUMBER

  """Boolean"""
  BOOLEAN

  """Address"""
  ADDRESS

  """Date"""
  DATE

  """Phone number"""
  PHONE_NUMBER

  """Custom field with defined answser list"""
  CUSTOM

  """A document"""
  DOCUMENT
}

input askNewValidationMailInput {
  """Pseudo of the user that wants to receive the validation mail"""
  pseudo: String

  """Email of the user that wants to receive the validation mail"""
  email: String
  clientMutationId: String
}

type askNewValidationMailPayload {
  viewer: Viewer
  clientMutationId: String
}

"""An assistant type, regarding its sport"""
type AssistantType implements Node {
  """The ID of an object"""
  id: ID!

  """Return a name: TranslatedString"""
  name: TranslatedString
}

"""Authorized accounts output type"""
type AuthorizedAccounts {
  """Id of the current user"""
  id: String

  """Pseudo of the current user"""
  pseudo: String

  """Avatar of the current user"""
  avatar: String

  """The type of the current user"""
  profileType: UserProfileType

  """Gives the number of unread notifications for this user"""
  numberOfUnreadNotifications: Int

  """Gives the number of unread chats for this user"""
  unreadChats: Int

  """List of authorized accounts with corresponding tokens"""
  accounts: [AuthorizedAccountsList]
}

"""List of authorized accounts with corresponding tokens"""
type AuthorizedAccountsList {
  """Id"""
  id: String

  """Pseudo"""
  pseudo: String

  """Avatar"""
  avatar: String

  """Token for this user"""
  token: String

  """Level of the authorization"""
  authorization_level: ManagementAuthorizationLevels

  """Gives the number of unread notifications for this user"""
  numberOfUnreadNotifications: Int

  """Gives the number of unread chats for this user"""
  unreadChats: Int

  """
  List of sub accounts with corresponding tokens for this authorized account
  """
  subAccounts: [AuthorizedUserSubAccounts]
}

"""List of users who can create / manage this account"""
type AuthorizedManager {
  """Return a Users for a given id"""
  user: User

  """Level of the authorization"""
  authorization_level: ManagementAuthorizationLevels
}

"""List of users who can create / manage this account"""
input AuthorizedManagerInput {
  """Id of the authorized user"""
  user: String

  """Level of authorization"""
  authorization_level: ManagementAuthorizationLevels
}

"""
List of sub accounts with corresponding tokens for this authorized account
"""
type AuthorizedUserSubAccounts {
  """Id"""
  id: String

  """Pseudo"""
  pseudo: String

  """Avatar"""
  avatar: String

  """Token for this user"""
  token: String

  """Gives the number of unread notifications for this user"""
  numberOfUnreadNotifications: Int

  """Gives the number of unread chats for this user"""
  unreadChats: Int
}

"""
Represent a user's preference for his participant's availability stats
"""
type availabilityStats {
  """Get the current statistic"""
  stat1: StatisticName

  """Get the current statistic"""
  stat2: StatisticName

  """Get the current statistic"""
  stat3: StatisticName

  """Get the current statistic"""
  stat4: StatisticName

  """Get the current statistic"""
  stat5: StatisticName
}

"""A bank account"""
type BankAccount {
  """The ID of an object"""
  id: ID!

  """First line of the address"""
  addressLine1: String

  """Second line of the address"""
  addressLine2: String

  """City of the owner of the bank account"""
  city: String

  """Postal code of the owner of the bank account"""
  postalCode: String

  """Country of the owner of the bank account"""
  country: String

  """Name of the owner of the bank account"""
  ownerName: String

  """IBAN of the bank account"""
  IBAN: String

  """BIC of the bank account"""
  BIC: String
}

"""Response from Mango Pay to create a bank wire"""
type BankWireToWallet {
  """Wire Reference to write in wire description"""
  wireReference: String

  """Type of the receiving bank account"""
  bankAccountType: String

  """Owner Name of the bank account receiving the wire"""
  ownerName: String

  """Owner Address of the bank account receiving the wire"""
  ownerAddress: String

  """IBAN of the receiving bank account"""
  IBAN: String

  """BIC of the receiving bank account"""
  BIC: String
}

"""Tells if the current user can test some specific features"""
type BetaTester {
  """
  Feature that allow to define specific prices for invited circles to sportunities
  """
  circlePrices: Boolean

  """Feature that allow to add statistics on sportunities"""
  statistics: Boolean

  """Feature that allow to add sub accounts and authorized users"""
  superUser: Boolean

  """Feature that allow to add secondary organizers to sportunities"""
  secondaryOrganizers: Boolean
}

input bookCarPoolingInput {
  """The ID of the sportunity"""
  sportunityID: String!

  """The ID of the car-pooling to book"""
  carPoolingID: String!

  """Bookers ID"""
  userID: String!
  clientMutationId: String
}

type bookCarPoolingPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

"""Let the user choose if he wants to receive notifications"""
type Business {
  """Name of the business"""
  businessName: String

  """Generic business email"""
  businessEmail: Email

  """The address of a user"""
  headquarterAddress: AddressModel

  """VAT number of the business"""
  VATNumber: String
}

"""Let the user choose if he wants to receive notifications"""
input BusinessInput {
  """Name of the business"""
  businessName: String

  """Generic business email"""
  businessEmail: Email

  """Address of the business headquarters"""
  headquarterAddress: AddressInput

  """VAT number of the business"""
  VATNumber: String
}

"""List of sportunities or users the current user added to his calendar"""
type Calendar {
  """The list of all Sportunities"""
  sportunities(
    after: String
    first: Int
    before: String
    last: Int

    """Description of a filter in Sportunity"""
    filter: Filter

    """ID of the user we want to chat with"""
    userId: String

    """ID of the sportunity wanted"""
    id: String
    orderBy: Sportunities_Order
  ): SportunityConnection

  """Return a bunch of Users for a given array of id"""
  users: [User]

  """Preferences of calendar synchronization"""
  preferences: CalendarPreferences
  user_status: [User_Status]
}

"""List of sportunities or users the current user added to his calendar"""
input CalendarInput {
  """List of sportunities the current user added to his calendar"""
  sportunities: [String]

  """List of users the current user added to his calendar"""
  users: [String]

  """Preferences of calendar synchronization"""
  preferences: CalendarPreferencesInput
}

"""Preferences of calendar synchronization"""
type CalendarPreferences {
  """List of synchronized events for current user"""
  own_synchronized_status: [SportunityStatus]
}

"""Preferences of calendar synchronization"""
input CalendarPreferencesInput {
  """List of synchronized events for current user"""
  own_synchronized_status: [SportunityStatus]
}

"""
If a user cancel his event booking, then he'll wait for someone to replace him

     If he's not replaced, he'll have to pay his booking
"""
enum cancelBookinStatus {
  """Canceling user is waiting to be replaced"""
  PENDING

  """Canceling user has been replaced"""
  REPLACED

  """The organizer refused the participation of this user"""
  REFUSED_BY_ORGANIZER
}

input cancelCarPoolingBookInput {
  """The ID of the sportunity"""
  sportunityID: String!

  """The ID of the car-pooling to cancel the book"""
  carPoolingID: String!

  """Bookers ID"""
  userID: String!
  clientMutationId: String
}

type cancelCarPoolingBookPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

"""Represent a user canceling his booking to a Sportunity"""
type Canceling {
  """Return a Users for a given id"""
  canceling_user: User

  """Tells if the user has been replaced or not"""
  status: cancelBookinStatus

  """Date of the cancelation"""
  cancelation_date: DateTime
}

input cancelSportunityInput {
  """The IDs of the sportunities to cancel"""
  sportunityIDs: [String]!
  clientMutationId: String
}

type cancelSportunityPayload {
  viewer: Viewer
  clientMutationId: String
}

"""Response from Mango Pay to register card information"""
type cardRegistration {
  """CardRegistration Id to pass to mutation to complete registration"""
  cardRegistrationId: String

  """A specific value to pass to the CardRegistrationURL"""
  preregistrationData: String

  """A special key to use when registering a card"""
  accessKey: String

  """The URL to submit the card details form to"""
  cardRegistrationURL: String
}

"""A car pooling"""
type CarPooling {
  """The ID of an object"""
  id: ID!

  """Return a Users for a given id"""
  driver: User

  """The address of a user"""
  address: AddressModel

  """Departure date"""
  starting_date: DateTime

  """Total number of sits"""
  number_of_sits: Int

  """Return a bunch of Users for a given array of id"""
  passengers: [User]
}

"""Represents a car pooling input"""
input CarPoolingInput {
  """Id of the driver"""
  driver: String

  """Address of the departure"""
  address: AddressInput

  """Date of the departure"""
  starting_date: String

  """Number of available sits in the car"""
  number_of_sits: Int
}

"""A certificate for a sport"""
type Certificate {
  """The ID of an object"""
  id: ID!

  """Return a name: TranslatedString"""
  name: TranslatedString
}

"""The level of a user for a given sport"""
type CertificateDescriptor {
  """Return the certificate"""
  certificate: Certificate

  """
  Tells if actual certificate has been validated by Sportunity Administration
  """
  validation: CertificateValidation!
}

"""Represents a certificate descriptor input"""
input CertificateDescriptorInput {
  """Id of the certificate"""
  certificate: String!

  """Tells users certificate has been validated"""
  validation: CertificateValidation
}

"""Represents a certificate input type"""
input CertificateInput {
  """The name of the certificate in different language"""
  name: StringTranslatedInput!
}

"""Specifies if a sport certificate is validated for a specific user"""
enum CertificateValidation {
  """Waiting for a validation"""
  PENDING

  """Certificate validation has been refused"""
  REJECTED

  """Certificate has been validated"""
  VALIDATED
}

input changePasswordInput {
  """Pseudo of the user that wants to change his password"""
  pseudo: String

  """Email of the user that wants to change his password"""
  email: String
  clientMutationId: String
}

type changePasswordPayload {
  viewer: Viewer
  clientMutationId: String
}

"""Represents a chat"""
type Chat implements Node {
  """The ID of an object"""
  id: ID!

  """A Sportunity"""
  sportunity(
    """ID of the sportunity wanted"""
    id: ID

    """External reference"""
    externalReference: String
  ): Sportunity

  """A circle"""
  circle(
    """ID of the circle wanted"""
    id: ID

    """Code to invit a member or a circle in a private circle"""
    code: String
  ): Circle

  """Return a bunch of Users for a given array of id"""
  users: [User]

  """The list of all messages sent to this entity"""
  messages(
    after: String
    first: Int
    before: String
    last: Int

    """The Id of the expeditor"""
    from: String
  ): MessageConnection

  """Get the number of messages in the current chat"""
  messageCount: Int

  """Current user has read the chat or not ?"""
  read: Boolean

  """Tells if the current chat is active or not"""
  isActive: Boolean
}

"""A connection to a list of items."""
type ChatConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ChatEdge]

  """Total number of tags"""
  count: Int
}

"""An edge in a connection."""
type ChatEdge {
  """The item at the end of the edge"""
  node: Chat

  """A cursor for use in pagination"""
  cursor: String!
}

"""A Circle of friends"""
type Circle implements Node {
  """The ID of an object"""
  id: ID!

  """The name of the circle"""
  name: String

  """Description of the circle"""
  description: String

  """Return a Users for a given id"""
  owner: User

  """The address of a user"""
  address: AddressModel

  """The sport information for a circle"""
  sport: CircleSport
  coOwners: [User]
  creation_status: CircleCreationStatus

  """The kind of Circle"""
  mode: CircleKind!

  """The type of this circle"""
  type: CircleTypeEnum
  members: [User]
  memberStatus: [memberStatus]

  """Return a bunch of Users for a given array of id"""
  memberParents: [User]

  """The number of users in the circle"""
  memberCount: Int!

  """Tells if the members of the circle can add new members"""
  isCircleUpdatableByMembers: Boolean

  """
  Tells if the members of this circle can invite this circle in a sportunity
  """
  isCircleUsableByMembers: Boolean

  """Tells if the circle can be accessed from its url for non-members"""
  isCircleAccessibleFromUrl: Boolean

  """Tells if the users can chat in the circle"""
  isChatActive: Boolean

  """Tells if the current user is a member of this circle"""
  isCurrentUserAMember: Boolean

  """Code to invit a member or a circle in a private circle"""
  publicShortCode: String

  """The list of all circles belonging to a given object"""
  circlesInPrivateMode(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection
  askedInformation: [askedInformation]
  membersInformation: [membersInformation]

  """The list of all circles belonging to a given object"""
  subCircles(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection

  """Payment models for this circle"""
  paymentModels: [CirclePaymentModel]
  memberConditions: [MemberCondition]
  circlePreferences: CirclePreferences
  sportunities: SportunityConnection

  """Returns the ToU for a specified circle"""
  termsOfUses: [CircleTermsOfUse]
}

"""A connection to a list of items."""
type CircleConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CircleEdge]

  """Total number of tags"""
  count: Int
}

"""Creation status of this circle"""
type CircleCreationStatus {
  """The status of current circle"""
  status: ValidationStatus

  """Tells the reason of the current status"""
  reason: String
}

"""An edge in a connection."""
type CircleEdge {
  """The item at the end of the edge"""
  node: Circle

  """A cursor for use in pagination"""
  cursor: String!
}

"""Represents a position on Earth"""
type CircleFilterLatLng {
  """The latitude of the position"""
  lat: Float

  """The longitude of the position"""
  lng: Float

  """Radius around coords to look for sportunities"""
  radius: Int
}

"""Represents a sport saved in filter"""
type CircleFilterSport {
  """Get a sport for object that have only one"""
  sport(
    """ID of the sport wanted"""
    id: ID
  ): Sport

  """Return a levels: TranslatedSportLevel"""
  levels: [Translated]
}

"""A form for personal information asked for circles"""
type CircleInformationFormOutput {
  """The ID of an object"""
  id: ID!
  name: String

  """The list of all circles belonging to a given object"""
  circles(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection
  askedInformation: [askedInformation]
  customFields: [customFields]
}

"""Represents a circle input type"""
input CircleInput {
  """Name of the circle"""
  name: String!

  """If null, taking current session as owner"""
  owner: String

  """Description of the circle"""
  description: String

  """The kind of Circle"""
  mode: CircleKind

  """The type of this circle"""
  type: CircleTypeEnum

  """The address of the Circle"""
  address: AddressInput

  """Selected sport, levels, positions and certificates"""
  sport: CircleSportInput

  """Tells if the members of the circle can add new members"""
  isCircleUpdatableByMembers: Boolean

  """
  Tells if the members of this circle can invite this circle in a sportunity
  """
  isCircleUsableByMembers: Boolean

  """Tells if the circle can be accessed from its url for non-members"""
  isCircleAccessibleFromUrl: Boolean

  """Tells if the users can chat in the circle"""
  isChatActive: Boolean

  """Ids of the circles that should be merged into one circle"""
  subCircles: [String]

  """The IDs of the circles from private mode to add"""
  circlesInPrivateMode: [String]

  """The status of current venue"""
  creation_status: CircleStatusInput
  circlePreferences: CirclePreferencesInput
}

"""Specifies which kind of circle it is"""
enum CircleKind {
  """
  The circle is public that means everyone can see it
        On the other side only and admin can change the members of this circle
  """
  PUBLIC

  """
  The circle is private, only its owner can see it and modify the members
  """
  PRIVATE
}

"""Specifies which type of circle it is"""
enum CircleListTypeEnum {
  """My circles"""
  MY_CIRCLES

  """Circles I'm in"""
  CIRCLES_I_AM_IN

  """Children / teams circles"""
  CHILDREN_CIRCLES

  """Public circles"""
  PUBLIC_CIRCLES

  """Other teams circles"""
  OTHER_TEAMS_CIRCLES
}

"""All the members from current user 's circles"""
type CircleMemberOutput {
  """Return a Users for a given id"""
  user: User
  circles: [CirclesMemberIsIn]
}

"""Gives the status of a member in a circle"""
enum CircleMemberStatus {
  """Member is active"""
  ACTIVE

  """Member is injured"""
  INJURED

  """Member is inactive"""
  INACTIVE

  """Any other status"""
  OTHER
}

"""A payment model for a circle"""
type CirclePaymentModel {
  """The ID of an object"""
  id: ID!

  """The name of the payment model"""
  name: String

  """Conditions available for this payment model"""
  conditions: [CirclePaymentModelCondition]

  """Get the Prices of an object"""
  price: Price

  """The list of all circles belonging to a given object"""
  circles(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection

  """Beginning date of the circle payment model"""
  beginning_date: DateTime

  """Ending date of the circle payment model"""
  ending_date: DateTime
  max_duration: Max_Duration

  """Number of uses available for the member"""
  max_uses: Int

  """the type of the membership fees"""
  memberShipFeesType: MemberShipFeesType

  """Allow members to pay membership fees in the app"""
  inAppPaymentAllowed: Boolean

  """Owner won't pay fees, members will"""
  memberToPayFees: Boolean

  """Allow members to pay membership fees via bank wire"""
  paymentViaBankWireAllowed: Boolean
  memberSubscriptions: [memberSubscriptions]
}

"""A payment model condition"""
type CirclePaymentModelCondition {
  """The ID of an object"""
  id: ID!

  """The name of the payment model condition"""
  name: String

  """Get the Prices of an object"""
  price: Price
  conditions: [PaymentModelConditionList]
}

"""Represents a circle payment model condition input type"""
input CirclePaymentModelConditionInput {
  """Id of the condition to update"""
  id: String

  """Name of the condition"""
  name: String!

  """The price for this condition"""
  price: PriceInput
  conditions: [PaymentModelConditionListInput]
}

"""Represents a circle payment model input type"""
input CirclePaymentModelInput {
  """Id of the payment model to update"""
  id: String

  """Name of the payment model"""
  name: String!

  """Conditions for this payment model"""
  conditions: [CirclePaymentModelConditionInput]

  """The price for this payment model"""
  price: PriceInput
  circles: [String]!

  """Beginning date of the circle payment model"""
  beginning_date: String

  """Ending date of the circle payment model"""
  ending_date: String
  max_duration: MaxDurationInput

  """Number of uses available for the member"""
  max_uses: Int

  """the type of the membership fees"""
  memberShipFeesType: MemberShipFeesType

  """Allow members to pay membership fees in the app"""
  inAppPaymentAllowed: Boolean

  """Owner won't pay fees, members will"""
  memberToPayFees: Boolean

  """Allow members to pay membership fees via bank wire"""
  paymentViaBankWireAllowed: Boolean
}

"""Information of the circle"""
type CirclePreferences {
  """Is this a circle containing only children ?"""
  isChildrenCircle: Boolean
}

"""Information of the circle"""
input CirclePreferencesInput {
  """Is this a circle containing only children ?"""
  isChildrenCircle: Boolean
}

"""Allow you to control which results are returned"""
input CirclesFilter {
  """Filter by location constraint"""
  location: LocationConstraint

  """Filter by sport name and level constraint"""
  sport: [SportConstraint]

  """Type of circle (adults, children, ...)"""
  type: CircleTypeEnum

  """Code to invit a member or a circle in a private circle"""
  code: String

  """Types of circle (adults, children, ...)"""
  types: [CircleTypeEnum]

  """List of circles"""
  circleType: [CircleListTypeEnum]

  """Few characters to search for a circle"""
  nameCompletion: String

  """Modes (private, public)"""
  modes: [CircleKind]

  """Filter by owners"""
  owners: [String]

  """Filter by isCircleUsableByMember"""
  isCircleUsableByMember: Boolean
}

"""List of circles"""
type CirclesMemberIsIn {
  """A circle"""
  circle(
    """ID of the circle wanted"""
    id: ID

    """Code to invit a member or a circle in a private circle"""
    code: String
  ): Circle
  isActive: Boolean
}

"""The sport of a circle"""
type CircleSport {
  """Get a sport for object that have only one"""
  sport(
    """ID of the sport wanted"""
    id: ID
  ): Sport

  """Return a levels: TranslatedSportLevel"""
  levels: [Translated]
}

"""Represents a circle's sport input"""
input CircleSportInput {
  """Id of the sport"""
  sport: String!

  """Ids of the levels"""
  levels: [String]
}

"""Statistics for an organizer"""
type CirclesStatisticsOrganizer {
  """Get the current statistic"""
  statisticName: StatisticName

  """Return a Users for a given id"""
  participant: User

  """Value of the statistic"""
  value: Int

  """Tells if the current stat is about availability"""
  isAvailabilityStat: Boolean
}

"""Represents a circle status input type"""
input CircleStatusInput {
  """The current status of the circle"""
  status: ValidationStatus

  """The reason of current status"""
  reason: String
}

"""A terms of use for a circle"""
type CircleTermsOfUse {
  """The ID of an object"""
  id: ID!

  """The name of the ToU"""
  name: String

  """The link of the ToU"""
  link: String

  """The content of the ToU"""
  content: String

  """The list of all circles belonging to a given object"""
  circles(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection
  acceptedBy: [TermsOfUseAcceptedBy]

  """Date of ToU creation"""
  creation_date: DateTime

  """Date of last ToU update (acceptations not included)"""
  update_date: DateTime
}

"""Represents a circle terms of use input type"""
input CircleTermsOfUseInput {
  """Id of the terms of use to update"""
  id: String

  """Name of the terms of use"""
  name: String!

  """Link of the terms of use"""
  link: String

  """Conditions of the terms of use"""
  content: String
  circles: [String]
}

"""Specifies which type of circle it is"""
enum CircleTypeEnum {
  """This circle will contain only adults"""
  ADULTS

  """This circle will contain only children"""
  CHILDREN

  """This circle will contain only teams"""
  TEAMS

  """This circle will contain only clubs"""
  CLUBS

  """This circle will contain only companies"""
  COMPANIES
}

"""A composition for a team"""
input CompositionInput {
  """Name of the composition"""
  name: String

  """Id of the owner"""
  owner: String

  """Field image choosen for this composition"""
  fieldImage: String

  """List of users and their position given in %"""
  users: [CompositionUsersInput]
}

"""A composition for a team"""
type CompositionOutput {
  """The ID of an object"""
  id: ID!

  """Name of the composition"""
  name: String

  """Return a Users for a given id"""
  owner: User

  """Field image choosen for this composition"""
  fieldImage: String

  """List of users and their position given in %"""
  users: [CompositionUsers]
}

"""Position"""
type CompositionUserPosition {
  """x Percentage of the user on the image (x1000)"""
  xPercentage: Int

  """y Percentage of the user on the image (x1000)"""
  yPercentage: Int
}

"""Position"""
input CompositionUserPositionInput {
  """x Percentage of the user on the image (x1000)"""
  xPercentage: Int

  """y Percentage of the user on the image (x1000)"""
  yPercentage: Int
}

"""List of users and their position given in % (x 1000)"""
type CompositionUsers {
  """Return a Users for a given id"""
  user: User

  """Position"""
  position: CompositionUserPosition
}

"""List of users and their position given in % (x 1000)"""
input CompositionUsersInput {
  """Id of the user"""
  user: String

  """Position"""
  position: CompositionUserPositionInput
}

"""represents access right on carPooling"""
type coOrganizersCarPoolingAccess {
  """access right to allow the organizer to see the carPooling"""
  view: Boolean

  """access right to allow the organizer to edit the carPooling"""
  edit: Boolean
}

"""represents access right on chat"""
type coOrganizersChatAccess {
  """access right to allow the organizer to see the chat"""
  view: Boolean

  """access right to allow the organizer to edit the chat"""
  edit: Boolean
}

"""represents access right on Compositions"""
type coOrganizersCompositionAccess {
  """access right to allow the organizer to see the Compositions"""
  view: Boolean

  """access right to allow the organizer to edit the Compositions"""
  edit: Boolean
}

"""represents access right on Details"""
type coOrganizersDetailsAccess {
  """access right to allow the organizer to see the Details"""
  view: Boolean

  """access right to allow the organizer to edit the Details"""
  edit: Boolean
}

"""represents access right on image"""
type coOrganizersImageAccess {
  """access right to allow the organizer to see the image"""
  view: Boolean

  """access right to allow the organizer to edit the image"""
  edit: Boolean
}

"""represents access right on carPooling"""
input coOrganizersInputCarPoolingAccess {
  """access right to allow the organizer to see the carPooling"""
  view: Boolean

  """access right to allow the organizer to edit the carPooling"""
  edit: Boolean
}

"""represents access right on chat"""
input coOrganizersInputChatAccess {
  """access right to allow the organizer to see the chat"""
  view: Boolean

  """access right to allow the organizer to edit the chat"""
  edit: Boolean
}

"""represents access right on composition tab"""
input coOrganizersInputCompositionAccess {
  """access right to allow the organizer to see the compositions"""
  view: Boolean

  """access right to allow the organizer to edit the compositions"""
  edit: Boolean
}

"""represents access right on main tab"""
input coOrganizersInputDetailsAccess {
  """access right to allow the organizer to see the details"""
  view: Boolean

  """access right to allow the organizer to edit the details"""
  edit: Boolean
}

"""represents access right on image"""
input coOrganizersInputImageAccess {
  """access right to allow the organizer to see the image"""
  view: Boolean

  """access right to allow the organizer to edit the image"""
  edit: Boolean
}

"""represents access right on member"""
input coOrganizersInputMemberAccess {
  """access right to allow the organizer to see the members"""
  view: Boolean

  """access right to allow the organizer to edit the members"""
  edit: Boolean
}

"""represents the access right of a co-organizers in a sportunity"""
input coOrganizersInputPermissions {
  detailsAccess: coOrganizersInputDetailsAccess
  chatAccess: coOrganizersInputChatAccess
  memberAccess: coOrganizersInputMemberAccess
  carPoolingAccess: coOrganizersInputCarPoolingAccess
  imageAccess: coOrganizersInputImageAccess
  compositionAccess: coOrganizersInputCompositionAccess
}

"""represents access right on member"""
type coOrganizersMemberAccess {
  """access right to allow the organizer to see the members"""
  view: Boolean

  """access right to allow the organizer to edit the members"""
  edit: Boolean
}

"""represents the access right of a co-organizers in a sportunity"""
type coOrganizersPermissions {
  detailsAccess: coOrganizersDetailsAccess
  chatAccess: coOrganizersChatAccess
  memberAccess: coOrganizersMemberAccess
  carPoolingAccess: coOrganizersCarPoolingAccess
  imageAccess: coOrganizersImageAccess
  compositionAccess: coOrganizersCompositionAccess
}

"""Represent any currency Sportunity supports"""
enum Currency {
  CHF
  EUR
  USD
}

"""custom fields add by the user in a form"""
type customFields {
  """The ID of an object"""
  id: ID!

  """The name of the field in the form"""
  name: String
}

"""custom fields add by the user in a form"""
input customFieldsInput {
  """Custom field id"""
  id: String

  """The name of the field in the form"""
  name: String
}

scalar DateTime

input deleteAskedInformationFormInput {
  id: String!
  clientMutationId: String
}

type deleteAskedInformationFormPayload {
  viewer: Viewer
  clientMutationId: String
}

input deleteCarPoolingInput {
  """The ID of the sportunity"""
  sportunityID: String!

  """The ID of the car-pooling to delete"""
  carPoolingID: String!
  clientMutationId: String
}

type deleteCarPoolingPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input deleteCircleInput {
  circleId: String!
  clientMutationId: String
}

type deleteCirclePayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input deleteCirclePaymentModelInput {
  paymentModelId: String!
  clientMutationId: String
}

type deleteCirclePaymentModelPayload {
  viewer: Viewer
  clientMutationId: String
}

input deleteCompositionInput {
  """The ID of the composition to delete"""
  compositionId: String
  clientMutationId: String
}

type deleteCompositionPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input deleteInfrastructureInput {
  infrastructureId: String!
  clientMutationId: String
}

type deleteInfrastructurePayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

input deletePaymentMethodInput {
  paymentMethodId: String
  clientMutationId: String
}

type deletePaymentMethodPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input deleteSlotInput {
  slotId: String!

  """Tells if the serie of slot should be deleted"""
  deleteSlotSerie: Boolean
  clientMutationId: String
}

type deleteSlotPayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

input deleteSportunityInput {
  """The ID of the sportunity to delete"""
  sportunityID: String!
  clientMutationId: String
}

type deleteSportunityPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input deleteUserInput {
  userId: String!
  clientMutationId: String
}

type deleteUserPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

"""A document"""
type DocumentObject {
  """The ID of an object"""
  id: ID!

  """The name of the Document"""
  name: String

  """The link of the Document"""
  link: String

  """Date of Document creation"""
  creation_date: DateTime
}

"""
The Email scalar type represents E-Mail addresses compliant to RFC 822.
"""
scalar Email

"""Let the user choose if he wants to receive emails"""
type EmailPreferences {
  """Email when user organizes a sportunity"""
  sportunityNewMainOrganizer: Boolean

  """Email when user is a secondary organizer of a new sportunity"""
  sportunityNewSecondaryOrganizer: Boolean

  """Email when user is a venue of a new sportunity"""
  sportunityNewVenueOrganizer: Boolean

  """Email when user is invited to a new sportunity"""
  sportunityNewInvited: Boolean

  """Email when a followed user creates a sportunity"""
  sportunityNewFollower: Boolean

  """Email when organizer cancels his sportunity"""
  sportunityCancelMainOrganizer: Boolean

  """
  Email when a sportunity where user is secondary organizer is cancelled
  """
  sportunityCancelSecondaryOrganizer: Boolean

  """Email when a sportunity where user is participant is cancelled"""
  sportunityCancelParticipant: Boolean

  """Email when user books a sportunity"""
  sportunityBooked: Boolean

  """Email when someone booked a sportunity where user is organizer"""
  sportunityBookedOrganizer: Boolean

  """Email when someone cancelled is booking to a sportunity"""
  sportunityBookerCancel: Boolean

  """
  Email when someone cancelled is booking to a sportunity where user is organizer
  """
  sportunityBookerCancelOrganizer: Boolean

  """Email to remind user when he has an unread message"""
  chatUnReadMessage: Boolean

  """Email when organizer modifies his sportunity"""
  sportunityModifiedMainOrganizer: Boolean

  """Email when a sportunity where user is secondary organizer is modified"""
  sportunityModifiedSecondaryOrganizer: Boolean

  """Email when a sportunity where user is venue is modified"""
  sportunityModifiedVenueOrganizer: Boolean

  """Email when a sportuntiy were user is participant is modified"""
  sportunityModifiedParticipant: Boolean

  """Email when participant's payment has been done"""
  paymentConfirmationOnDDay: Boolean

  """Email for main organizer when he received a payment"""
  paymentReceivedMainOrganizer: Boolean

  """Email for secondary organizer when he received a payment"""
  paymentReceivedSecondaryOrganizer: Boolean

  """Email when user's certificate has been validated by admin user"""
  certificateValidated: Boolean
}

"""Let the user choose if he wants to receive emails"""
input EmailPreferencesInput {
  """Email when user organizes a sportunity"""
  sportunityNewMainOrganizer: Boolean

  """Email when user is a secondary organizer of a new sportunity"""
  sportunityNewSecondaryOrganizer: Boolean

  """Email when user is a venue of a new sportunity"""
  sportunityNewVenueOrganizer: Boolean

  """Email when user is invited to a new sportunity"""
  sportunityNewInvited: Boolean

  """Email when a followed user creates a sportunity"""
  sportunityNewFollower: Boolean

  """Email when organizer cancels his sportunity"""
  sportunityCancelMainOrganizer: Boolean

  """
  Email when a sportunity where user is secondary organizer is cancelled
  """
  sportunityCancelSecondaryOrganizer: Boolean

  """Email when a sportunity where user is participant is cancelled"""
  sportunityCancelParticipant: Boolean

  """Email when user books a sportunity"""
  sportunityBooked: Boolean

  """Email when someone booked a sportunity where user is organizer"""
  sportunityBookedOrganizer: Boolean

  """Email when someone cancelled is booking to a sportunity"""
  sportunityBookerCancel: Boolean

  """
  Email when someone cancelled is booking to a sportunity where user is organizer
  """
  sportunityBookerCancelOrganizer: Boolean

  """Email to remind user when he has an unread message"""
  chatUnReadMessage: Boolean

  """Email when organizer modifies his sportunity"""
  sportunityModifiedMainOrganizer: Boolean

  """Email when a sportunity where user is secondary organizer is modified"""
  sportunityModifiedSecondaryOrganizer: Boolean

  """Email when a sportunity where user is venue is modified"""
  sportunityModifiedVenueOrganizer: Boolean

  """Email when a sportuntiy were user is participant is modified"""
  sportunityModifiedParticipant: Boolean

  """Email when participant's payment has been done"""
  paymentConfirmationOnDDay: Boolean

  """Email for main organizer when he received a payment"""
  paymentReceivedMainOrganizer: Boolean

  """Email for secondary organizer when he received a payment"""
  paymentReceivedSecondaryOrganizer: Boolean

  """Email when user's certificate has been validated by admin user"""
  certificateValidated: Boolean
}

"""Who should be excluded from the invited list"""
type excludedInvitees {
  """Statuses of members to exclude"""
  excludedStatus: [CircleMemberStatus]

  """Return a bunch of Users for a given array of id"""
  excludedMembers: [User]

  """Should this event invite parents"""
  excludeParents: Boolean
}

"""Who should be excluded from the invited list"""
input excludedInviteesInput {
  """Statuses of members to exclude"""
  excludedStatus: [CircleMemberStatus]

  """Ids of members to exclude"""
  excludedMembers: [String]

  """Should this event invite parents"""
  excludeParents: Boolean
}

"""If participant by default = true, who should be excluded"""
type excludedParticipantByDefault {
  """Statuses of members to exclude"""
  excludedStatus: [CircleMemberStatus]

  """Return a bunch of Users for a given array of id"""
  excludedMembers: [User]

  """Should this event include parents as participant by default"""
  excludeParents: Boolean
}

"""If participant by default = true, who should be excluded"""
input excludedParticipantByDefaultInput {
  """Statuses of members to exclude"""
  excludedStatus: [CircleMemberStatus]

  """Ids of members to exclude"""
  excludedMembers: [String]

  """Should this event include parents as participant by default"""
  excludeParents: Boolean
}

"""A Feedback from a user on another Object"""
type Feedback implements Node {
  """The ID of an object"""
  id: ID!

  """The content of the feedback"""
  text: String

  """The grade associated to this feedback (1-5)"""
  rating: Int!

  """Return a Users for a given id"""
  author: User

  """When the feedback was written"""
  createdAt: DateTime!
}

"""A connection to a list of items."""
type FeedbackConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [FeedbackEdge]

  """Total number of tags"""
  count: Int
}

"""An edge in a connection."""
type FeedbackEdge {
  """The item at the end of the edge"""
  node: Feedback

  """A cursor for use in pagination"""
  cursor: String!
}

"""Represents a feedback input type"""
input FeedbackInput {
  text: String!

  """The rating of the feedback"""
  rating: Int!

  """The id of the user which wrote the feedback"""
  author: String!

  """The date of creation of the feedback"""
  createdAt: String!
}

enum FeedbackOrder {
  """Order by date of creation of the feedback"""
  DATE

  """Order by the given rating"""
  RATING
}

"""An object representing the feedback of the community"""
type Feedbacks {
  """The number of feedbacks"""
  count: Int!

  """The average rate given by the community"""
  averageRating: Float

  """The list of feedbacks on this object"""
  feedbacksList(
    after: String
    first: Int
    before: String
    last: Int

    """On which critera do you want to order the feedbacks"""
    orderBy: FeedbackOrder
  ): FeedbackConnection
}

"""Allow you to control which results are returned"""
input Filter {
  """Filter by location constraint"""
  location: LocationConstraint

  """Filter by sport name and level constraint"""
  sport: [SportConstraint]

  """Status of sportunities"""
  status: SportunityStatus

  """Name of a sportunity or organizer pseudo"""
  searchByName: String

  """Array of status of sportunities"""
  statuses: [SportunityStatus]

  """The interval of price to filter"""
  price: IntIntervalInput

  """The interval of dates to filter"""
  dates: StringIntervalInput

  """The interval of hours of the beginning hours to filter"""
  hours: IntIntervalInput

  """Kind of sportunities : PRIVATE or PUBLIC"""
  kind: SportunityKind

  """Sex restriction to filter sportunities"""
  sexRestriction: SexRestriction

  """Age restriction to filter sportunities"""
  ageRestriction: IntIntervalInput

  """ID of the users to get their sportunities"""
  users: [String]

  """ID of the circles to get sportunities those circles are invited in"""
  circles: [String]

  """ID of the sub-accounts to get their sportunities"""
  subAccounts: [String]

  """List of opponent Ids"""
  opponents: [String]

  """List of IDs of sportunity types to filter"""
  sportunityTypes: [String]
}

"""Represents a position on Earth"""
type FilterLatLng {
  """The latitude of the position"""
  lat: Float

  """The longitude of the position"""
  lng: Float

  """Radius around coords to look for sportunities"""
  radius: Int
}

"""Represents a sport saved in filter"""
type FilterSport {
  """Get a sport for object that have only one"""
  sport(
    """ID of the sport wanted"""
    id: ID
  ): Sport

  """Return a levels: TranslatedSportLevel"""
  levels: [Translated]
}

"""Information of the game : opponent, season, ... """
type GameInformation {
  """Information about the opponent"""
  opponent: SportunityOpponentOutput
}

"""Information of the game : opponent, season, ... """
input GameInformationInput {
  """Information about the opponent"""
  opponent: SportunityOpponentInput
}

"""Information of the game : opponent, season, ... """
input GameInformationUpdateInput {
  """Information about the opponent"""
  opponent: SportunityOpponentUpdateInput
}

"""Default page that is loading when a user logs in"""
enum HomePagePreference {
  """Find sportunities page / Explore"""
  FIND

  """My Sportunities page"""
  ORGANIZED
}

"""An information filled"""
input Information {
  """Id of the asked information"""
  id: String!

  """The filled information"""
  value: String

  """The document to answer the asked information"""
  documentId: String
}

"""Represents an infrastructure of a venue"""
type Infrastructure implements Node {
  """The ID of an object"""
  id: ID!
  venue: Venue

  """The name of the infrastructure (ex court 1)"""
  name: String!

  """The list of sports playable in an infrastructre"""
  sport: [Sport]

  """The a list slots"""
  slots(
    """ID of the infrastructure we want the avaialbe slots of"""
    id: ID

    """ID of the sportunity user is updating"""
    updatingSportunity: ID

    """Description of a filter in Sportunity"""
    filter: Filter
  ): [Slot]

  """Logo of the infrastructure"""
  logo: String

  """Get the Prices of an object"""
  price: Price
  authorized_managers: [InfrastructureAuthorizedManager]
}

"""List of available authorizations levels for user to an infrastructure"""
enum InfrastructureAuthorizationLevels {
  """User can create timeslots as he wants"""
  FULL_CONSUMER

  """User can create timeslots on certain conditions"""
  CONSUMER
}

"""List of users who can manage this infrastructure"""
type InfrastructureAuthorizedManager {
  """Return a Users for a given id"""
  user: User

  """A circle"""
  circle(
    """ID of the circle wanted"""
    id: ID

    """Code to invit a member or a circle in a private circle"""
    code: String
  ): Circle

  """Level of the authorization"""
  authorization_level: InfrastructureAuthorizationLevels
}

"""List of users who can manage this infrastructure"""
input InfrastructureAuthorizedManagerInput {
  """Id of the authorized user"""
  user: String

  """Id of the authorized circle"""
  circle: String

  """Level of authorization"""
  authorization_level: InfrastructureAuthorizationLevels
}

"""Represents an infrastructure input type"""
input InfrastructureInput {
  """The infrastructure id to update (if needed)"""
  id: String
  name: String!

  """The id of the sport available in the infrastructure"""
  sport: [String]

  """Logo of the infrastructure"""
  logo: String

  """The default price of the infrastructure"""
  price: PriceInput
  authorized_managers: [InfrastructureAuthorizedManagerInput]
}

"""Represent an interval of Int"""
type IntInterval {
  """The lower bound of the interval"""
  from: Int

  """The upper bound of the interval"""
  to: Int
}

"""Represent an interval input of Int"""
input IntIntervalInput {
  """The lower bound of the interval"""
  from: Int!

  """The upper bound of the interval"""
  to: Int!
}

"""Represent a user invited to a Sportunity"""
type Invited {
  """Return a Users for a given id"""
  user: User

  """Tells the answer of the invited user"""
  answer: invitedUserAnswer
}

input invitedAnswersSurveyInput {
  """The ID of the sportunity to update"""
  sportunityID: String!

  """The ID of the user answering"""
  userId: String!
  answers: [SurveyInvitedAnswers]!
  clientMutationId: String
}

type invitedAnswersSurveyPayload {
  sportunity: Sportunity
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

"""Represents an invited circle to a sportunity input type"""
input InvitedCircleInput {
  circle: String

  """Price that members of the current circle would pay if they book"""
  price: PriceInput

  """
  Tells if members of the current circle should be participants by default (for free sportunities only)
  """
  participantByDefault: Boolean

  """If participant by default = true, who should be excluded"""
  excludedParticipantByDefault: excludedParticipantByDefaultInput

  """Who should be excluded from the invited list"""
  excludedInvitees: excludedInviteesInput
}

"""Represents an invited user to a sportunity input type"""
input InvitedInput {
  user: String

  """The pseudo of the invited user"""
  pseudo: String

  """Tells if the organizer has accepted the invitation"""
  answer: invitedUserAnswer!
}

input InvitedListToAdd {
  """The ID of the user to invite"""
  invitedId: String

  """If the new user doesn't exist, define a pseudo for him"""
  invitedPseudo: String

  """If the new user doesn't exist, his email"""
  invitedEmail: String
}

"""List of available status for invited users"""
enum invitedUserAnswer {
  WAITING

  """The user confirmed his booking"""
  YES

  """The user refused the invitation"""
  NO
}

"""All the languages a user can speak"""
type Language {
  """The ID of an object"""
  id: ID!

  """Language code"""
  code: String

  """Language name"""
  name: String
}

"""Represents a location constraint"""
input LocationConstraint {
  """The latitude of the center"""
  lat: Float

  """The longitude of the center"""
  lng: Float

  """The radius of the constraint"""
  radius: Float
}

"""Locked amount on the wallet : to pay booked sportunities"""
type LockedAmountOnWallet {
  """The amount locked on the wallet"""
  cents: Int

  """Currency"""
  currency: Currency
}

input mailValidationInput {
  """Token to validate email address"""
  token: String!
  clientMutationId: String
}

type mailValidationPayload {
  viewer: Viewer
  clientMutationId: String
}

"""List of available authorizations levels for user to another"""
enum ManagementAuthorizationLevels {
  """
  The authorized user can login, see sportunities ... but can't create anything or manage the account
  """
  READER

  """
  The authorized user can login, see and create sportunities ... but can't manage the account
  """
  WRITER

  """The authorized user can login, and manage everything in the account"""
  ADMIN
}

"""Votes for man of the game for this sportunity"""
type manOfTheGameVotes {
  """Return a Users for a given id"""
  voter: User

  """Return a Users for a given id"""
  votedFor: User

  """Date of the vote"""
  date: DateTime
}

"""Duration this payment is valid for"""
type Max_Duration {
  days: Int
  months: Int
  years: Int
}

"""Duration this payment is valid for"""
input MaxDurationInput {
  days: Int
  months: Int
  years: Int
}

"""Conditions that the member has chosen"""
type MemberCondition {
  """Return a Users for a given id"""
  member: User

  """Conditions chosen by the member"""
  chosenCondition: [CirclePaymentModelCondition]
}

"""List of available type for membership fees"""
enum MemberShipFeesType {
  """Membership will be valid for a fixed period of time"""
  Period_Paiement

  """Membership will pay a certain number of activities"""
  Customizable

  """
  Membership will be valid from a defined period of time after the date when member join  group
  """
  Flexible_Period_Paiement
}

"""Members informations for a specific circle"""
type membersInformation {
  """The ID of an object"""
  id: ID!

  """Id of the asked information"""
  information: String

  """Return a Users for a given id"""
  user: User

  """Filled answer"""
  value: String

  """A document"""
  document(
    """ID of the wanted document"""
    documentId: ID
  ): DocumentObject

  """Date of filling"""
  fillingDate: DateTime

  """Answer was validated by forms's owner"""
  validationStatus: ValidationStatus

  """Comment by form's owner"""
  comment: String
}

"""Members status for a specific circle"""
type memberStatus {
  """Return a Users for a given id"""
  member: User
  status: CircleMemberStatus

  """Beginning of the status"""
  starting_date: DateTime

  """Ending of the status"""
  ending_date: DateTime
}

"""Status for members of the cirle"""
input MemberStatusInput {
  memberId: String!
  status: CircleMemberStatus!
}

input memberSubscribeToPaymentModelInput {
  """Id of member"""
  userId: String!

  """Id of the payment model"""
  paymentModelId: String!

  """Id of the payment method (card)"""
  paymentMethodId: String

  """Tells if the user wants to pay with his wallet"""
  paymentWithWallet: Boolean

  """The amount the user will pay"""
  amount: PriceInput!
  clientMutationId: String
}

type memberSubscribeToPaymentModelPayload {
  edge: CircleEdge
  viewer: Viewer

  """URL sent by MangoPay to use 3D Secure"""
  secure3DURL: String
  clientMutationId: String
}

"""Represents the subsription of the members"""
type memberSubscriptions {
  """Return a Users for a given id"""
  user: User
  beginning_date: DateTime
  ending_date: DateTime

  """Get the Prices of an object"""
  amount: Price
  payment_date: DateTime
}

"""The members that user is participating with"""
type MembersUserParticipatesWith {
  """Return a Users for a given id"""
  user: User

  """
  Number of times the user is participating to a sportunity with this member
  """
  number: Int
}

"""Represents a message"""
type Message implements Node {
  """The ID of an object"""
  id: ID!

  """The content of the message"""
  text: String!

  """Return a Users for a given id"""
  author: User

  """When the message was written"""
  created: DateTime!
}

"""A connection to a list of items."""
type MessageConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [MessageEdge]

  """Total number of tags"""
  count: Int
}

"""An edge in a connection."""
type MessageEdge {
  """The item at the end of the edge"""
  node: Message

  """A cursor for use in pagination"""
  cursor: String!
}

"""Represents a message input type"""
input MessageInput {
  text: String!

  """The ID of the author of the message"""
  author: String!
}

type Mutation {
  newUser(input: newUserInput!): newUserPayload
  upUser(input: upUserInput!): upUserPayload
  validateUser(input: validateUserInput!): validateUserPayload
  reportUser(input: reportUserInput!): reportUserPayload
  mailValidation(input: mailValidationInput!): mailValidationPayload
  askNewValidationMail(input: askNewValidationMailInput!): askNewValidationMailPayload
  changePassword(input: changePasswordInput!): changePasswordPayload
  updatePassword(input: updatePasswordInput!): updatePasswordPayload
  unfollowUser(input: unfollowUserInput!): unfollowUserPayload
  setDefaultFilter(input: setDefaultFilterInput!): setDefaultFilterPayload
  setDefaultCircleFilter(input: setDefaultCircleFilterInput!): setDefaultCircleFilterPayload
  updateTutorialStep(input: updateTutorialStepInput!): updateTutorialStepPayload
  setDefaultStatisticFilter(input: setDefaultStatisticFilterInput!): setDefaultStatisticFilterPayload
  deleteUser(input: deleteUserInput!): deleteUserPayload
  userAddDocument(input: userAddsDocumentInput!): userAddsDocumentPayload
  userRemoveDocument(input: userRemoveDocumentInput!): userRemoveDocumentPayload
  newSportunity(input: newSportunityInput!): newSportunityPayload
  newOpponentSportunity(input: newOpponentSportunityInput!): newOpponentSportunityPayload
  updateSportunity(input: updateSportunityInput!): updateSportunityPayload
  deleteSportunity(input: deleteSportunityInput!): deleteSportunityPayload
  organizerAddParticipants(input: organizerAddParticipantsInput!): organizerAddParticipantsPayload
  organizerAddInviteds(input: organizerAddInvitedsInput!): organizerAddInvitedsPayload
  organizerAddInvitedCircles(input: organizerAddInvitedCirclesInput!): organizerAddInvitedCirclesPayload
  secondaryOrganizerPickRole(input: secondaryOrganizerPickRoleInput!): secondaryOrganizerPickRolePayload
  secondaryOrganizerCancelRole(input: secondaryOrganizerCancelRoleInput!): secondaryOrganizerCancelRolePayload
  secondaryOrganizerRefuseRole(input: secondaryOrganizerRefuseRoleInput!): secondaryOrganizerRefuseRolePayload
  newCarPooling(input: newCarPoolingInput!): newCarPoolingPayload
  updateCarPooling(input: updateCarPoolingInput!): updateCarPoolingPayload
  deleteCarPooling(input: deleteCarPoolingInput!): deleteCarPoolingPayload
  bookCarPooling(input: bookCarPoolingInput!): bookCarPoolingPayload
  cancelCarPoolingBook(input: cancelCarPoolingBookInput!): cancelCarPoolingBookPayload
  askCarPooling(input: askCarPoolingInput!): askCarPoolingPayload
  addEventImage(input: addSportunityImageInput!): addSportunityImagePayload
  removeEventImage(input: removeSportunityImageInput!): removeSportunityImagePayload
  invitedAnswersSurvey(input: invitedAnswersSurveyInput!): invitedAnswersSurveyPayload
  organizerPickDate(input: organizerPickSurveyDateInput!): organizerPickSurveyDatePayload
  addSecondaryOrganizer(input: addSecondaryOrganizerInput!): addSecondaryOrganizerPayload
  removeSecondaryOrganizer(input: removeSecondaryOrganizerInput!): removeSecondaryOrganizerPayload
  addPendingSecondaryOrganizer(input: addPendingSecondaryOrganizerInput!): addPendingSecondaryOrganizerPayload
  addCircle(input: addCircleInput!): addCirclePayload
  updateTitle(input: updateTitleInput!): updateTitlePayload
  updateTime(input: updateTimeInput!): updateTimePayload
  updateDescription(input: updateDescriptionInput!): updateDescriptionPayload
  cancelSportunity(input: cancelSportunityInput!): cancelSportunityPayload
  userBooksEvent(input: userBooksEventInput!): userBooksEventPayload
  newSport(input: newSportInput!): newSportPayload
  updateSport(input: updateSportInput!): updateSportPayload
  newSportunityType(input: newSportunityTypeInput!): newSportunityTypePayload
  updateSportunityType(input: updateSportunityTypeInput!): updateSportunityTypePayload
  removeSportunityType(input: removeSportunityTypeInput!): removeSportunityTypePayload
  newSportunityTypeStatus(input: newSportunityTypeStatusInput!): newSportunityTypeStatusPayload
  updateSportunityTypeStatus(input: updateSportunityTypeStatusInput!): updateSportunityTypeStatusPayload
  removeSportunityTypeStatus(input: removeSportunityTypeStatusInput!): removeSportunityTypeStatusPayload
  newAssistantType(input: newAssistantTypeInput!): newAssistantTypePayload
  updateAssistantType(input: updateAssistantTypeInput!): updateAssistantTypePayload
  removeAssistantType(input: removeAssistantTypeInput!): removeAssistantTypePayload
  newVenue(input: newVenueInput!): newVenuePayload
  updateVenue(input: updateVenueInput!): updateVenuePayload
  newSlot(input: newSlotInput!): newSlotPayload
  updateSlot(input: updateSlotInput!): updateSlotPayload
  deleteSlot(input: deleteSlotInput!): deleteSlotPayload
  newInfrastructure(input: newInfrastructureInput!): newInfrastructurePayload
  updateInfrastructure(input: updateInfrastructureInput!): updateInfrastructurePayload
  deleteInfrastructure(input: deleteInfrastructureInput!): deleteInfrastructurePayload
  addMsg(input: addMsgInput!): addMsgPayload
  readChat(input: readChatInput!): readChatPayload
  newCircle(input: newCircleInput!): newCirclePayload
  updateCircle(input: updateCircleInput!): updateCirclePayload
  deleteCircle(input: deleteCircleInput!): deleteCirclePayload
  addCircleMember(input: addCircleMemberInput!): addCircleMemberPayload
  updateCirclesInPrivateMode(input: updateCirclesInPrivateModeInput!): updateCirclesInPrivateModePayload
  addCircleMembers(input: addCircleMembersInput!): addCircleMembersPayload
  addParentMember(input: addParentMemberInput!): addParentMemberPayload
  removeParent(input: removeCircleParentInput!): removeCircleParentPayload
  removeCircleMember(input: removeCircleMemberInput!): removeCircleMemberPayload
  updateAskedInformation(input: updateAskedInformationInput!): updateAskedInformationPayload
  updateAskedInformationForm(input: updateAskedInformationFormInput!): updateAskedInformationFormPayload
  deleteAskedInformationForm(input: deleteAskedInformationFormInput!): deleteAskedInformationFormPayload
  updateFilledInformation(input: updateFilledInformationInput!): updateFilledInformationPayload
  relaunchMembersForAskedInformation(input: relaunchMembersForAskedInformationInput!): relaunchMembersForAskedInformationPayload
  ownerValidateDocument(input: ownerValidateDocumentInput!): ownerValidateDocumentPayload
  newCirclePaymentModel(input: newCirclePaymentModelInput!): newCirclePaymentModelPayload
  updateCirclePaymentModel(input: updateCirclePaymentModelInput!): updateCirclePaymentModelPayload
  deleteCirclePaymentModel(input: deleteCirclePaymentModelInput!): deleteCirclePaymentModelPayload
  relaunchMembers(input: relaunchMembersForMembershipFeesInput!): relaunchMembersForMembershipFeesPayload
  memberSubscribes(input: memberSubscribeToPaymentModelInput!): memberSubscribeToPaymentModelPayload
  updateMemberStatus(input: updateCircleMemberStatusInput!): updateCircleMemberStatusPayload
  newTermsOfUse(input: newCircleTermsOfUseInput!): newCircleTermsOfUsePayload
  updateTermsOfUse(input: updateCircleTermsOfUseInput!): updateCircleTermsOfUsePayload
  removeTermsOfUse(input: removeCircleTermsOfUseInput!): removeCircleTermsOfUsePayload
  acceptTermsOfUse(input: acceptCircleTermsOfUseInput!): acceptCircleTermsOfUsePayload
  relaunchTermsOfUseValidation(input: relaunchMembersForTermsOfUseValidationInput!): relaunchMembersForTermsOfUseValidationPayload
  registerCardData(input: registerCardDataInput!): registerCardDataPayload
  registerBankAccount(input: registerBankAccountInput!): registerBankAccountPayload
  deletePaymentMethod(input: deletePaymentMethodInput!): deletePaymentMethodPayload
  requireCashOut(input: requireCashOutInput!): requireCashOutPayload
  requireCashIn(input: requireCashInInput!): requireCashInPayload
  readNotifications(input: readNotificationsInput!): readNotificationsPayload
  readNotification(input: readNotificationInput!): readNotificationPayload
  updateStatisticPreferences(input: updateStatisticPreferencesInput!): updateStatisticPreferencesPayload
  updateSportunityStatistic(input: updateSportunityStatisticsInput!): updateSportunityStatisticsPayload
  voteForManOfTheGame(input: voteForManOfTheGameInput!): voteForManOfTheGamePayload
  newStatisticFilter(input: newStatisticFilterInput!): newStatisticFilterPayload
  updateStatisticFilter(input: updateStatisticFilterInput!): updateStatisticFilterPayload
  removeStatisticFilter(input: removeStatisticFilterInput!): removeStatisticFilterPayload
  newSportunityTemplate(input: newSportunityTemplateInput!): newSportunityTemplatePayload
  updateSportunityTemplate(input: updateSportunityTemplateInput!): updateSportunityTemplatePayload
  removeSportunityTemplate(input: removeSportunityTemplateInput!): removeSportunityTemplatePayload
  newComposition(input: newCompositionInput!): newCompositionPayload
  updateComposition(input: updateCompositionInput!): updateCompositionPayload
  deleteComposition(input: deleteCompositionInput!): deleteCompositionPayload
  changeEventCompositions(input: updateSportunityCompositionsInput!): updateSportunityCompositionsPayload
  importNewUser(
    """The unique pseudo of the user"""
    pseudo: String!

    """FirstName of the user"""
    firstName: String

    """FirstName of the user"""
    lastName: String

    """The unique email of the user"""
    email: Email

    """The password of the user"""
    password: String

    """The gender of the user"""
    sex: Sex!

    """The type of user"""
    profileType: UserProfileType

    """Email of the parent / club"""
    superAccountEmail: String

    """Pseudo of the team, so this user is authorized to manage the team"""
    teamPseudo: String

    """Id of the sport the team practices"""
    sportId: String

    """Circle names to create for this user"""
    circleList: [String]
    externalReference: String
  ): User
  importNewSportunity(
    team1Pseudo: String!
    team1externalReference: String
    team2Pseudo: String!
    team2externalReference: String
    description: String!
    address: String!
    zip: Int
    city: String!
    country: String
    sport: String!
    price: Int!
    participantRangeMin: Int!
    participantRangeMax: Int!

    """The mode of the Sportunity"""
    mode: SportunityMode!

    """The kind of the Sportunity (private / public)"""
    kind: SportunityKind!

    """Beginning date of the sportunity"""
    beginning_date: String!

    """Ending date of the sportunity"""
    ending_date: String!
    team1Score: Int
    team2Score: Int
    externalReference: String
  ): Sportunity
  importUpdateSportunity(
    externalReference: String
    description: String!
    address: String!
    zip: Int
    city: String!
    country: String

    """Beginning date of the sportunity"""
    beginning_date: String!

    """Ending date of the sportunity"""
    ending_date: String!
    team1Score: Int
    team2Score: Int
  ): Sportunity

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node
}

input newAssistantTypeInput {
  """Sport type to create this event types"""
  sportType: SportTypeEnum!

  """The name of this event type"""
  name: StringTranslatedInput
  clientMutationId: String
}

type newAssistantTypePayload {
  assistantType: AssistantType
  viewer: Viewer
  clientMutationId: String
}

input newCarPoolingInput {
  """The ID of the sportunity to update"""
  sportunityID: String!

  """Car pooling input type"""
  carPooling: CarPoolingInput
  clientMutationId: String
}

type newCarPoolingPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input newCircleInput {
  """A Circle input type"""
  circle: CircleInput
  clientMutationId: String
}

type newCirclePayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input newCirclePaymentModelInput {
  paymentModel: CirclePaymentModelInput
  clientMutationId: String
}

type newCirclePaymentModelPayload {
  viewer: Viewer
  clientMutationId: String
}

input newCircleTermsOfUseInput {
  termsOfUse: CircleTermsOfUseInput
  clientMutationId: String
}

type newCircleTermsOfUsePayload {
  viewer: Viewer
  termsOfUse: CircleTermsOfUse
  clientMutationId: String
}

input newCompositionInput {
  """A User input type"""
  composition: CompositionInput
  clientMutationId: String
}

type newCompositionPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input newInfrastructureInput {
  venueId: String!
  infrastructure: InfrastructureInput
  clientMutationId: String
}

type newInfrastructurePayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

input newNotificationSubscriptionInput {
  clientSubscriptionId: String
}

type newNotificationSubscriptionPayload {
  edge: NotificationEdge
  viewer: Viewer
  clientSubscriptionId: String
}

input newOpponentSportunityInput {
  sportunityId: String!
  clientMutationId: String
}

type newOpponentSportunityPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input newSlotInput {
  venueId: String!
  infrastructureId: String!
  slot: SlotInput
  repetitionNumber: Int
  clientMutationId: String
}

type newSlotPayload {
  edge: VenueEdge
  slot: Slot
  viewer: Viewer
  clientMutationId: String
}

input newSportInput {
  """a Sport input type"""
  sport: SportInput
  clientMutationId: String
}

type newSportPayload {
  edge: SportEdge
  viewer: Viewer
  clientMutationId: String
}

input newSportunityInput {
  """A Sportunity input type"""
  sportunity: SportunityInput

  """Tells if participants & invitees should be notified for this event"""
  notify_people: Boolean
  clientMutationId: String
}

type newSportunityPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input newSportunityTemplateInput {
  """A Sportunity template input type"""
  sportunityTemplate: SportunityTemplateInput
  clientMutationId: String
}

type newSportunityTemplatePayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input newSportunityTypeInput {
  """Sport type to create this event types"""
  sportType: SportTypeEnum!

  """The name of this event type"""
  name: StringTranslatedInput

  """Tells if a score can be set on this sportunity type"""
  isScoreRelevant: Boolean
  clientMutationId: String
}

type newSportunityTypePayload {
  sportunityType: SportunityType
  viewer: Viewer
  clientMutationId: String
}

input newSportunityTypeStatusInput {
  """Id of the sportunity type to create this status"""
  sportunityTypeID: String!

  """The name of this status"""
  name: StringTranslatedInput
  clientMutationId: String
}

type newSportunityTypeStatusPayload {
  sportunityTypeStatus: SportunityTypeStatus
  viewer: Viewer
  clientMutationId: String
}

input newStatisticFilterInput {
  """Name of the filter"""
  name: String!

  """Beginning date of the filter"""
  date_begin: String

  """Ending date of the filter"""
  date_end: String

  """List of circles of the filter"""
  circleList: [String]
  clientMutationId: String
}

type newStatisticFilterPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input newUserInput {
  """A User input type"""
  user: UserInput

  """Token of the super user creating this account"""
  superUserToken: String
  clientMutationId: String
}

type newUserPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input newVenueInput {
  """A Venue input type"""
  venue: VenueInput
  clientMutationId: String
}

type newVenuePayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

"""Represents a notification"""
type Notification implements Node {
  """The ID of an object"""
  id: ID!

  """Title of the notification"""
  title: String

  """The content of the notification"""
  text: String!

  """The link of the notification when the user clicks on it"""
  link: String

  """Tells when the notification was created"""
  created: DateTime!

  """Image to show on list of notifications"""
  image: String

  """Type of notification"""
  notificationType: String

  """Tells if the notification is read or not"""
  isRead: Boolean
}

"""A connection to a list of items."""
type NotificationConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [NotificationEdge]

  """Total number of tags"""
  count: Int
}

"""An edge in a connection."""
type NotificationEdge {
  """The item at the end of the edge"""
  node: Notification

  """A cursor for use in pagination"""
  cursor: String!
}

"""Represents a notification type input"""
input NotificationPreferenceInput {
  """Type of notification to send to invited users"""
  notification_type: SportunityNotificationPreference

  """
  If organizer wants to send the notification automatically x days before sportunity's beginning
  """
  send_notification_x_days_before: Int
}

"""Let the user choose if he wants to receive notifications"""
type NotificationPreferences {
  """Notification when user organizes a sportunity"""
  sportunityNewMainOrganizer: Boolean

  """Notification when user is a secondary organizer of a new sportunity"""
  sportunityNewSecondaryOrganizer: Boolean

  """Notification when user is a venue of a new sportunity"""
  sportunityNewVenueOrganizer: Boolean

  """Notification when user is invited to a new sportunity"""
  sportunityNewInvited: Boolean

  """Notification when a followed user creates a sportunity"""
  sportunityNewFollower: Boolean

  """Notification when organizer cancels his sportunity"""
  sportunityCancelMainOrganizer: Boolean

  """
  Notification when a sportunity where user is secondary organizer is cancelled
  """
  sportunityCancelSecondaryOrganizer: Boolean

  """Notification when a sportunity where user is participant is cancelled"""
  sportunityCancelParticipant: Boolean

  """Notification when user books a sportunity"""
  sportunityBooked: Boolean

  """Notification when someone booked a sportunity where user is organizer"""
  sportunityBookedOrganizer: Boolean

  """Notification when someone cancelled is booking to a sportunity"""
  sportunityBookerCancel: Boolean

  """
  Notification when someone cancelled is booking to a sportunity where user is organizer
  """
  sportunityBookerCancelOrganizer: Boolean

  """Notification when organizer modifies his sportunity"""
  sportunityModifiedMainOrganizer: Boolean

  """
  Notification when a sportunity where user is secondary organizer is modified
  """
  sportunityModifiedSecondaryOrganizer: Boolean

  """Notification when a sportunity where user is venue is modified"""
  sportunityModifiedVenueOrganizer: Boolean

  """Notification when a sportuntiy were user is participant is modified"""
  sportunityModifiedParticipant: Boolean

  """Notification when participant's payment has been done"""
  paymentConfirmationOnDDay: Boolean

  """Notification for main organizer when he received a payment"""
  paymentReceivedMainOrganizer: Boolean

  """Notification for secondary organizer when he received a payment"""
  paymentReceivedSecondaryOrganizer: Boolean

  """Notification when user's certificate has been validated by admin user"""
  certificateValidated: Boolean

  """Notification to complete statistics"""
  sportunityCompleteStatistics: Boolean

  """Notification to vote for the man of the game"""
  sportunityVoteForManOfTheGame: Boolean
}

"""Let the user choose if he wants to receive notifications"""
input NotificationPreferencesInput {
  """Notification when user organizes a sportunity"""
  sportunityNewMainOrganizer: Boolean

  """Notification when user is a secondary organizer of a new sportunity"""
  sportunityNewSecondaryOrganizer: Boolean

  """Notification when user is a venue of a new sportunity"""
  sportunityNewVenueOrganizer: Boolean

  """Notification when user is invited to a new sportunity"""
  sportunityNewInvited: Boolean

  """Notification when a followed user creates a sportunity"""
  sportunityNewFollower: Boolean

  """Notification when organizer cancels his sportunity"""
  sportunityCancelMainOrganizer: Boolean

  """
  Notification when a sportunity where user is secondary organizer is cancelled
  """
  sportunityCancelSecondaryOrganizer: Boolean

  """Notification when a sportunity where user is participant is cancelled"""
  sportunityCancelParticipant: Boolean

  """Notification when user books a sportunity"""
  sportunityBooked: Boolean

  """Notification when someone booked a sportunity where user is organizer"""
  sportunityBookedOrganizer: Boolean

  """Notification when someone cancelled is booking to a sportunity"""
  sportunityBookerCancel: Boolean

  """
  Notification when someone cancelled is booking to a sportunity where user is organizer
  """
  sportunityBookerCancelOrganizer: Boolean

  """Notification when organizer modifies his sportunity"""
  sportunityModifiedMainOrganizer: Boolean

  """
  Notification when a sportunity where user is secondary organizer is modified
  """
  sportunityModifiedSecondaryOrganizer: Boolean

  """Notification when a sportunity where user is venue is modified"""
  sportunityModifiedVenueOrganizer: Boolean

  """Notification when a sportuntiy were user is participant is modified"""
  sportunityModifiedParticipant: Boolean

  """Notification when participant's payment has been done"""
  paymentConfirmationOnDDay: Boolean

  """Notification for main organizer when he received a payment"""
  paymentReceivedMainOrganizer: Boolean

  """Notification for secondary organizer when he received a payment"""
  paymentReceivedSecondaryOrganizer: Boolean

  """Notification when user's certificate has been validated by admin user"""
  certificateValidated: Boolean

  """Notification to complete statistics"""
  sportunityCompleteStatistics: Boolean

  """Notification to vote for the man of the game"""
  sportunityVoteForManOfTheGame: Boolean
}

"""Represents a notification type input"""
input NotificationPreferenceUpdateInput {
  """Type of notification to send to invited users"""
  notification_type: SportunityNotificationPreference

  """
  If organizer wants to send the notification automatically x days before sportunity's beginning
  """
  send_notification_x_days_before: Int
}

"""Represent an organizer of a Sportunity"""
type Organizer implements Node {
  """The ID of an object"""
  id: ID!

  """Return a Users for a given id"""
  organizer: User

  """Tells if the given user is an administrator of this event"""
  isAdmin: Boolean!

  """Tells what is the role of this user in this event"""
  role: OrganizerRole!

  """Get the Prices of an object"""
  price: Price

  """Get the type of asssistant profile for a sportunity"""
  secondaryOrganizerType: AssistantType

  """Custom Role (if the role is not in our database)"""
  customSecondaryOrganizerType: String
  permissions: coOrganizersPermissions
}

input organizerAddInvitedCirclesInput {
  """The ID of the sportunity"""
  sportunityID: String!
  invitedCircles: [String]!
  clientMutationId: String
}

type organizerAddInvitedCirclesPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input organizerAddInvitedsInput {
  """The ID of the sportunity"""
  sportunityID: String!
  inviteds: [InvitedListToAdd]!

  """If needed, can put this invited list in a specific circle"""
  putInvitedsInCircle: String
  clientMutationId: String
}

type organizerAddInvitedsPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input organizerAddParticipantsInput {
  """The ID of the sportunity"""
  sportunityID: String!
  participants: [ParticipantListToAdd]!

  """If needed, can put this participant list in a specific circle"""
  putParticipantsInCircle: String
  clientMutationId: String
}

type organizerAddParticipantsPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

"""Represents an organizer input type"""
input OrganizerInput {
  organizer: String!

  """Tells if the organizer is administrator"""
  isAdmin: Boolean!

  """Tells the role of the organizer"""
  role: OrganizerRole!

  """The amount to give to this organizer"""
  price: PriceInput

  """Type id of secondary organizer"""
  secondaryOrganizerType: String

  """Custom Role (if the role is not in our database)"""
  customSecondaryOrganizerType: String
  permissions: coOrganizersInputPermissions
}

input organizerPickSurveyDateInput {
  """The ID of the sportunity to update"""
  sportunityID: String!

  """The beginning date of the choosen proposition"""
  beginning_date: String

  """The ending date of the choosen proposition"""
  ending_date: String
  clientMutationId: String
}

type organizerPickSurveyDatePayload {
  edge: SportunityEdge
  viewer: Viewer
  sportunity: Sportunity
  clientMutationId: String
}

"""List of available roles an organizer can have on an event"""
enum OrganizerRole {
  """The organizer will coach participants"""
  COACH

  """The organizer will host the event"""
  VENUE
}

input ownerValidateDocumentInput {
  circleId: String!
  filledInformationId: String!

  """Id of the documnet to validate / refuse"""
  documentId: String!

  """True to validate doc / False to refuse doc"""
  isValidated: Boolean

  """Comment from the owner"""
  comment: String
  clientMutationId: String
}

type ownerValidateDocumentPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

input ParticipantListToAdd {
  """The ID of the participant to add"""
  participantId: String

  """If the new participant doesn't exist, define a pseudo for him"""
  participantPseudo: String

  """If the new participant doesn't exist, his email"""
  participantEmail: String
}

"""Payment method"""
type PaymentMethod implements Node {
  """The ID of an object"""
  id: ID!

  """CardRegistration Id to pass to mutation to complete registration"""
  cardType: String

  """A specific value to pass to the CardRegistrationURL"""
  cardMask: String

  """The expiry date of the card"""
  expirationDate: String
}

type PaymentModelConditionList {
  askedInformation: askedInformation

  """Comparator :  ; < ; = ; > ; """
  askedInformationComparator: String

  """
  If asked information is number, number. If it's a boolean, 1 === true ; 0 === false
  """
  askedInformationComparatorValue: Int

  """If asked information is a String"""
  askedInformationComparatorValueString: String

  """If asked information is date"""
  askedInformationComparatorDate: DateTime
}

input PaymentModelConditionListInput {
  """Id of the asked information"""
  askedInformation: String

  """Comparator :  ; < ; = ; > ; """
  askedInformationComparator: String

  """
  If asked information is number, number. If it's a boolean, 1 === true ; 0 === false
  """
  askedInformationComparatorValue: Int

  """If asked information is a String"""
  askedInformationComparatorValueString: String

  """If asked information is date"""
  askedInformationComparatorDate: String
}

"""Status of event payments"""
enum PaymentStatus {
  """
  If user's card was verified & the sportunity will begin in more than 7 days
  """
  Pending

  """
  If the sportunity begins in less than 7 days, the event price is locked on his card
  """
  Locked

  """If the sportunity is passed, and the user paid it"""
  Done

  """If the sportunity is passed, and he payment failed"""
  Error

  """If user canceled and he has been replaced"""
  Canceled
}

"""Describes the method of payment"""
type PaymentWith {
  """Describes the method of the transaction"""
  method: TransactionMethod

  """The payment method the user choose for an event"""
  paymentMethod: PaymentMethod
}

"""represents access right on carPooling"""
type pendingCoOrganizersCarPoolingAccess {
  """access right to allow the organizer to see the carPooling"""
  view: Boolean

  """access right to allow the organizer to edit the carPooling"""
  edit: Boolean
}

"""represents access right on chat"""
type pendingCoOrganizersChatAccess {
  """access right to allow the organizer to see the chat"""
  view: Boolean

  """access right to allow the organizer to edit the chat"""
  edit: Boolean
}

"""represents access right on Compositions"""
type pendingCoOrganizersCompositionAccess {
  """access right to allow the organizer to see the Compositions"""
  view: Boolean

  """access right to allow the organizer to edit the Compositions"""
  edit: Boolean
}

"""represents access right on Details"""
type pendingCoOrganizersDetailsAccess {
  """access right to allow the organizer to see the Details"""
  view: Boolean

  """access right to allow the organizer to edit the Details"""
  edit: Boolean
}

"""represents access right on image"""
type pendingCoOrganizersImageAccess {
  """access right to allow the organizer to see the image"""
  view: Boolean

  """access right to allow the organizer to edit the image"""
  edit: Boolean
}

"""represents access right on carPooling"""
input pendingCoOrganizersInputCarPoolingAccess {
  """access right to allow the organizer to see the carPooling"""
  view: Boolean

  """access right to allow the organizer to edit the carPooling"""
  edit: Boolean
}

"""represents access right on chat"""
input pendingCoOrganizersInputChatAccess {
  """access right to allow the organizer to see the chat"""
  view: Boolean

  """access right to allow the organizer to edit the chat"""
  edit: Boolean
}

"""represents access right on composition tab"""
input pendingCoOrganizersInputCompositionAccess {
  """access right to allow the organizer to see the compositions"""
  view: Boolean

  """access right to allow the organizer to edit the compositions"""
  edit: Boolean
}

"""represents access right on main tab"""
input pendingCoOrganizersInputDetailsAccess {
  """access right to allow the organizer to see the details"""
  view: Boolean

  """access right to allow the organizer to edit the details"""
  edit: Boolean
}

"""represents access right on image"""
input pendingCoOrganizersInputImageAccess {
  """access right to allow the organizer to see the image"""
  view: Boolean

  """access right to allow the organizer to edit the image"""
  edit: Boolean
}

"""represents access right on member"""
input pendingCoOrganizersInputMemberAccess {
  """access right to allow the organizer to see the members"""
  view: Boolean

  """access right to allow the organizer to edit the members"""
  edit: Boolean
}

"""represents the access right of a co-organizers in a sportunity"""
input pendingCoOrganizersInputPermissions {
  detailsAccess: pendingCoOrganizersInputDetailsAccess
  chatAccess: pendingCoOrganizersInputChatAccess
  memberAccess: pendingCoOrganizersInputMemberAccess
  carPoolingAccess: pendingCoOrganizersInputCarPoolingAccess
  imageAccess: pendingCoOrganizersInputImageAccess
  compositionAccess: pendingCoOrganizersInputCompositionAccess
}

"""represents access right on member"""
type pendingCoOrganizersMemberAccess {
  """access right to allow the organizer to see the members"""
  view: Boolean

  """access right to allow the organizer to edit the members"""
  edit: Boolean
}

"""represents the access right of a co-organizers in a sportunity"""
type pendingCoOrganizersPermissions {
  detailsAccess: pendingCoOrganizersDetailsAccess
  chatAccess: pendingCoOrganizersChatAccess
  memberAccess: pendingCoOrganizersMemberAccess
  carPoolingAccess: pendingCoOrganizersCarPoolingAccess
  imageAccess: pendingCoOrganizersImageAccess
  compositionAccess: pendingCoOrganizersCompositionAccess
}

"""Represent an pending organizer of a Sportunity"""
type PendingOrganizer implements Node {
  """The ID of an object"""
  id: ID!

  """The list of all circles belonging to a given object"""
  circles(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection

  """Tells if the given user is an administrator of this event"""
  isAdmin: Boolean!

  """Tells what is the role of this user in this event"""
  role: OrganizerRole!

  """Get the Prices of an object"""
  price: Price

  """Get the type of asssistant profile for a sportunity"""
  secondaryOrganizerType: AssistantType

  """Custom Role (if the role is not in our database)"""
  customSecondaryOrganizerType: String
  permissions: pendingCoOrganizersPermissions
}

"""Represents a list of pending organizers input type"""
input PendingOrganizerInput {
  """If updating a pending organizer object"""
  id: String
  circles: [String]!

  """Tells if the organizer is administrator"""
  isAdmin: Boolean!

  """Tells the role of the organizer"""
  role: OrganizerRole!

  """The amount to give to this organizer"""
  price: PriceInput

  """Type id of secondary organizer"""
  secondaryOrganizerType: String

  """Custom Role (if the role is not in our database)"""
  customSecondaryOrganizerType: String
  permissions: pendingCoOrganizersInputPermissions
}

"""A physical position"""
type PositionType {
  lat: Float
  lng: Float
}

"""Represents a price"""
type Price {
  """The currency in which this price was set"""
  currency: Currency

  """
  The amount of specified currency
  
            Important: The value is in cents to avoid Floating point error !!
            
  """
  cents: Int!

  """Return a description: TranslatedString"""
  description: TranslatedString
}

"""Prices for invited circles"""
type PriceForCircle {
  """A circle"""
  circle(
    """ID of the circle wanted"""
    id: ID

    """Code to invit a member or a circle in a private circle"""
    code: String
  ): Circle

  """Get the Prices of an object"""
  price: Price

  """
  Tells if members of the current circle should be participants by default (for free sportunities only)
  """
  participantByDefault: Boolean

  """If participant by default = true, who should be excluded"""
  excludedParticipantByDefault: excludedParticipantByDefault

  """Who should be excluded from the invited list"""
  excludedInvitees: excludedInvitees
}

"""Represents a price input type"""
input PriceInput {
  currency: Currency!

  """The amount of specified currency in cents"""
  cents: Int!
}

"""
Represents the preference of the organizer for privacy switching of the sportunity
"""
input PrivacySwitchPreferenceInput {
  """Type of switch to change from private to public the sportunity"""
  privacy_switch_type: SportunityPrivacySwitchPreference

  """
  If organizer wants to switch the kind from private to public automatically x days before sportunity's beginning
  """
  switch_privacy_x_days_before: Int
}

"""
Represents the preference of the organizer for privacy switching of the sportunity
"""
type PrivacySwitchPreferenceOutput {
  """Type of switch to change from private to public the sportunity"""
  privacy_switch_type: SportunityPrivacySwitchPreference

  """
  If organizer wants to switch the kind from private to public automatically x days before sportunity's beginning
  """
  switch_privacy_x_days_before: Int
}

"""
Represents the preference of the organizer for privacy switching of the sportunity
"""
input PrivacySwitchPreferenceUpdateInput {
  """Type of switch to change from private to public the sportunity"""
  privacy_switch_type: SportunityPrivacySwitchPreference

  """
  If organizer wants to switch the kind from private to public automatically x days before sportunity's beginning
  """
  switch_privacy_x_days_before: Int
}

type Query {
  viewer: Viewer

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node
}

input readChatInput {
  """The ID of the chat to read"""
  chatId: String
  clientMutationId: String
}

type readChatPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input readNotificationInput {
  notificationId: String!
  clientMutationId: String
}

type readNotificationPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input readNotificationsInput {
  clientMutationId: String
}

type readNotificationsPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input registerBankAccountInput {
  """The address of the owner of the bank account"""
  addressLine1: String!

  """The address of the owner of the bank account"""
  addressLine2: String

  """The city where lives the owner of the bank account"""
  city: String!

  """The postal code of the city where the owner of the bank account lives"""
  postalCode: String!

  """The country of the owner of the bank account"""
  country: String!

  """The name of the owner of the bank account"""
  ownerName: String!

  """The IBAN of the bank account"""
  IBAN: String!

  """The BIC of the bank account"""
  BIC: String
  clientMutationId: String
}

type registerBankAccountPayload {
  viewer: Viewer
  clientMutationId: String
}

input registerCardDataInput {
  """CardRegistration Id given by query in first place"""
  cardRegistrationId: String!

  """
  Having registered a card, this confirmation hash needs to be updated to the card item
  """
  registrationData: String!
  clientMutationId: String
}

type registerCardDataPayload {
  paymentMethodId: String
  viewer: Viewer
  clientMutationId: String
}

input relaunchMembersForAskedInformationInput {
  circleId: String!
  clientMutationId: String
}

type relaunchMembersForAskedInformationPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input relaunchMembersForMembershipFeesInput {
  paymentMethodId: String!
  clientMutationId: String
}

type relaunchMembersForMembershipFeesPayload {
  viewer: Viewer
  clientMutationId: String
}

input relaunchMembersForTermsOfUseValidationInput {
  termOfUsesId: String!
  clientMutationId: String
}

type relaunchMembersForTermsOfUseValidationPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input removeAssistantTypeInput {
  """ID of the assistant type to remove"""
  assistantTypeID: String!
  clientMutationId: String
}

type removeAssistantTypePayload {
  assistantType: AssistantType
  viewer: Viewer
  clientMutationId: String
}

input removeCircleMemberInput {
  circleId: String!
  userId: String
  pseudo: String
  email: String
  clientMutationId: String
}

type removeCircleMemberPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input removeCircleParentInput {
  circleId: String!
  userId: String!
  clientMutationId: String
}

type removeCircleParentPayload {
  edge: CircleEdge
  viewer: Viewer
  circle: Circle
  clientMutationId: String
}

input removeCircleTermsOfUseInput {
  """Id of the ToU to delete"""
  termsOfUseId: String!
  clientMutationId: String
}

type removeCircleTermsOfUsePayload {
  viewer: Viewer
  clientMutationId: String
}

input removeSecondaryOrganizerInput {
  """The IDs of the sportunities to update"""
  sportunityIDs: [String]!

  """Organizer input"""
  organizer: OrganizerInput!
  clientMutationId: String
}

type removeSecondaryOrganizerPayload {
  viewer: Viewer
  clientMutationId: String
}

input removeSportunityImageInput {
  """The ID of the sportunity to update"""
  sportunityID: String!

  """URL of the image to remove"""
  imageUrl: String!
  clientMutationId: String
}

type removeSportunityImagePayload {
  sportunity: Sportunity
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input removeSportunityTemplateInput {
  """Id of the template to remove"""
  sportunityTemplateId: String!
  clientMutationId: String
}

type removeSportunityTemplatePayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input removeSportunityTypeInput {
  """ID of the sportunity type to remove"""
  sportunityTypeID: String!
  clientMutationId: String
}

type removeSportunityTypePayload {
  sportunityType: SportunityType
  viewer: Viewer
  clientMutationId: String
}

input removeSportunityTypeStatusInput {
  """ID of the sportunity type status to remove"""
  sportunityTypeStatusID: String!
  clientMutationId: String
}

type removeSportunityTypeStatusPayload {
  sportunityTypeStatus: SportunityTypeStatus
  viewer: Viewer
  clientMutationId: String
}

input removeStatisticFilterInput {
  """Id of the filter to remove"""
  statisticFilterId: String!
  clientMutationId: String
}

type removeStatisticFilterPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

"""Represent a reporter user input type"""
type ReporterUser implements Node {
  """The ID of an object"""
  id: ID!

  """Return a Users for a given id"""
  user: User

  """Tells why the user has been reported"""
  reason: String
}

input reportUserInput {
  """The ID of the user to report"""
  userID: String

  """Reason of the report"""
  reason: String
  clientMutationId: String
}

type reportUserPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input requireCashInInput {
  """User owning the wallet"""
  userId: String!

  """The amount the user wants to cash out"""
  amount: PriceInput!

  """Payment method Id to take cash fron"""
  paymentMethodId: String!
  clientMutationId: String
}

type requireCashInPayload {
  viewer: Viewer

  """URL sent by MangoPay to use 3D Secure"""
  secure3DURL: String
  clientMutationId: String
}

input requireCashOutInput {
  """User owning the wallet"""
  userId: String!

  """The amount the user wants to cash out"""
  amount: PriceInput!
  clientMutationId: String
}

type requireCashOutPayload {
  viewer: Viewer
  clientMutationId: String
}

"""Save a circle filter"""
input SavedCircleFilterInput {
  """Id of the filter"""
  userCircleFilterId: String

  """Name of the filter"""
  filterName: String

  """Tells if the filter can be deleted"""
  canBeDeleted: Boolean

  """Filter by location constraint"""
  location: LocationConstraint

  """Filter by sport name and level constraint"""
  sport: [SportConstraint]

  """List of circles"""
  circleType: [CircleListTypeEnum]

  """The type of the members"""
  memberType: CircleTypeEnum

  """Types of circle"""
  memberTypes: [CircleTypeEnum]

  """Modes (private, public)"""
  modes: [CircleKind]

  """Filter by owners"""
  owners: [String]

  """The position of this filter in the list"""
  position: Int
}

"""Represents the score of the current sportunity"""
type Score {
  """Score of the current team"""
  currentTeam: Int

  """Score of the adversary team"""
  adversaryTeam: Int
}

"""Represents the score of the current sportunity"""
input ScoreInput {
  """Score of the current team"""
  currentTeam: Int

  """Score of the adversary team"""
  adversaryTeam: Int
}

input secondaryOrganizerCancelRoleInput {
  """The ID of the sportunity to update"""
  sportunityID: String!

  """Tells if the user wants to cancel his co-organization to the serie"""
  cancelSerie: Boolean
  clientMutationId: String
}

type secondaryOrganizerCancelRolePayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input secondaryOrganizerPickRoleInput {
  """The ID of the sportunity to update"""
  sportunityID: String!

  """The ID of the pending Organizer object"""
  pendingOrganizerID: String!
  clientMutationId: String
}

type secondaryOrganizerPickRolePayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input secondaryOrganizerRefuseRoleInput {
  """The ID of the sportunity to update"""
  sportunityID: String!

  """The ID of the pending Organizer object"""
  pendingOrganizerID: String!
  clientMutationId: String
}

type secondaryOrganizerRefuseRolePayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

"""Informations on the serie"""
type serie_information {
  firstDate: DateTime
  lastDate: DateTime
  remainingSlots: Int
}

input setDefaultCircleFilterInput {
  """ID of the filter to set as default"""
  filterID: String
  clientMutationId: String
}

type setDefaultCircleFilterPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input setDefaultFilterInput {
  """ID of the filter to set as default"""
  filterID: String
  clientMutationId: String
}

type setDefaultFilterPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input setDefaultStatisticFilterInput {
  """ID of the filter to set as default"""
  filterID: String
  clientMutationId: String
}

type setDefaultStatisticFilterPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

"""User's gender"""
enum Sex {
  """Male user"""
  MALE

  """Female user"""
  FEMALE

  """Unknown gender, or companies"""
  OTHER
}

"""Gender restriction on events"""
enum SexRestriction {
  """Only males are allowed"""
  MALE

  """Only females are allowed"""
  FEMALE

  """No restrictions on sex"""
  NONE
}

"""An open access time slot"""
type Slot implements Node {
  """The ID of an object"""
  id: ID!
  venue: Venue
  infrastructure: Infrastructure

  """The time the slot starts"""
  from: DateTime!

  """The time the slot ends"""
  end: DateTime!

  """Get the Prices of an object"""
  price: Price

  """Return a bunch of Users for a given array of id"""
  usersSlotIsFor: [User]

  """The list of all circles belonging to a given object"""
  circlesSlotIsFor(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection

  """Tells if the current slot is flexible or not"""
  flexible: Boolean

  """A Sportunity"""
  sportunity(
    """ID of the sportunity wanted"""
    id: ID

    """External reference"""
    externalReference: String
  ): Sportunity

  """Get the slot status"""
  status: SlotStatus

  """Return a Users for a given id"""
  user_creating: User

  """Tells if current slot is part of a serie"""
  is_repeated: Boolean

  """Occurence number if the slot is in a serie"""
  is_repeated_occurence_number: Int

  """Number of occurences in the serie if the actual slot is in a serie"""
  number_of_occurences: Int
  serie_information: serie_information
}

"""Represents a slot input type"""
input SlotInput {
  """The slot id to update (if needed)"""
  id: String
  from: String!

  """The time the slot ends"""
  end: String!

  """The price of the slot"""
  price: PriceInput

  """Id of the users this slot is made for"""
  usersSlotIsFor: [String]

  """Id of the circles this slot is made for"""
  circlesSlotIsFor: [String]

  """Tells if the current slot is flexible or not"""
  flexible: Boolean
}

"""A slot status"""
enum SlotStatus {
  """Nothing on this slot"""
  PENDING

  """A Sportunity is planned on this """
  PLANNED

  """A past slot"""
  PAST

  """A slot with a cancelled sportunity"""
  CANCELLED
}

"""A Sportunity Sport"""
type Sport implements Node {
  """The ID of an object"""
  id: ID!

  """Return a name: TranslatedString"""
  name: TranslatedString

  """The logo for this sport in SVG format"""
  logo: String!

  """Return a positions: TranslatedString"""
  positions: [TranslatedString]

  """Return the certificates of a given object"""
  certificates: [Certificate]

  """Return a levels: TranslatedSportLevel"""
  levels: [Translated]

  """Tells if the sport is active or not"""
  status: status

  """Type of this sport"""
  type: SportTypeEnum

  """Get the available types of events for a sport"""
  sportunityTypes(
    """Sport type to get the event types possible"""
    sportType: SportTypeEnum
  ): [SportunityType]

  """Get the available types of asssistant profile for a sport"""
  assistantTypes(
    """Sport type to get the event types possible"""
    sportType: SportTypeEnum
  ): [AssistantType]

  """Images of the field"""
  fieldImages: [String]
}

"""A connection to a list of items."""
type SportConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [SportEdge]

  """Total number of tags"""
  count: Int
}

"""Represents a sport constraint"""
input SportConstraint {
  """The id of the sport"""
  sportID: String

  """The levels ids"""
  level: [String]
}

"""The level of a user for a given sport"""
type SportDescriptor {
  """Get a sport for object that have only one"""
  sport(
    """ID of the sport wanted"""
    id: ID
  ): Sport

  """Return a levels: TranslatedSportLevel"""
  levels: [Translated]

  """Return the certificates descriptor"""
  certificates: [CertificateDescriptor]

  """Return a positions: TranslatedString"""
  positions: [TranslatedString]

  """Get the available types of asssistant profile for a sport"""
  assistantType(
    """Sport type to get the event types possible"""
    sportType: SportTypeEnum
  ): [AssistantType]
}

"""Represents a sport descriptor input"""
input SportDescriptorInput {
  """Id of the sport"""
  sport: String!

  """Ids of the levels"""
  levels: [String]

  """List of certificates the user has"""
  certificates: [CertificateDescriptorInput]

  """The positions the user plays in the sport"""
  positions: [String]

  """The assistants the user can be"""
  assistantType: [String]
}

"""An edge in a connection."""
type SportEdge {
  """The item at the end of the edge"""
  node: Sport

  """A cursor for use in pagination"""
  cursor: String!
}

"""Allow you to control which results are returned"""
input SportFilter {
  """Name or part of the name of the searched sport"""
  name: String

  """Language of the sport's name searched"""
  language: SupportedLanguage!
}

"""Represents a sport input type"""
input SportInput {
  """The name of the sport in different langauges"""
  name: StringTranslatedInput!

  """The logo for this sport in SVG format"""
  logo: String!

  """The list of postions in different langauges"""
  positions: [StringTranslatedInput]

  """The list of certicates"""
  certificates: [CertificateInput]

  """The list of the levels in different langauges"""
  levels: [SportLevelInputTranslatedInput]

  """Type of this sport"""
  type: SportTypeEnum

  """Images of the field"""
  fieldImages: [String]
}

"""A skill level for a given sport"""
type SportLevel {
  """The name of the sport level in a language"""
  name: String

  """The description of a sport level in a language"""
  description: String

  """
  The absolute skill score associated to this level
  
          This is used to compare sport level in different coutries
  """
  skillLevel: Int!
}

"""Represents a sport level input type"""
input SportLevelInput {
  """The name of the sport level in a language"""
  name: String

  """The description of a sport level in a language"""
  description: String

  """
  The absolute skill score associated to this level
  
        This is used to compare sport level in different coutries
  """
  skillLevel: Int!
}

"""Represent a translated SportLevelInput"""
input SportLevelInputTranslatedInput {
  FR: SportLevelInput
  EN: SportLevelInput
  DE: SportLevelInput
  ES: SportLevelInput
}

"""Specifies which type of sport it is"""
enum SportTypeEnum {
  """A team vs another"""
  COLLECTIVE

  """Combat sports"""
  COMBAT

  """Racket sports"""
  RACKETSPORT

  """Other sports"""
  OTHER
}

enum Sportunities_Order {
  BEGINNING_DATE_ASC
  BEGINNING_DATE_DESC
  CREATION_DATE_ASC
  CREATION_DATE_DESC
}

enum SportunitiesOrganizers_Order {
  BEGINNING_DATE_ASC
  BEGINNING_DATE_DESC
  CREATION_DATE_ASC
  CREATION_DATE_DESC
}

"""Statistics for an organizer"""
type SportunitiesStatisticsOrganizer {
  """Get the sportunity type"""
  sportunityType: SportunityType

  """Get the sportunity type status"""
  sportunityTypeStatus: SportunityTypeStatus

  """Value of the statistic"""
  value: Int
  details: [StatisticDetails]
}

"""A sportunity (Event)"""
type Sportunity implements Node {
  """The ID of an object"""
  id: ID!

  """The title of the sportunity"""
  title: String!

  """The description of the Sportunity"""
  description: String!

  """The address of a user"""
  address: AddressModel

  """Get a venue for object that have only one"""
  venue(
    """ID of the sportunity wanted"""
    id: ID
  ): Venue

  """Get the infrastructure of an object"""
  infrastructure(
    """ID of the infrastructure wanted"""
    id: ID
  ): Infrastructure

  """A slot"""
  slot(
    """ID of the slot we want"""
    id: ID
  ): Slot

  """Get the list of organizers"""
  organizers: [Organizer]

  """Get the list of pending organizers"""
  pendingOrganizers: [PendingOrganizer]

  """The number of share this Sportunity has"""
  nbShares: Int

  """Return a bunch of Users for a given array of id"""
  participants: [User]
  canceling: [Canceling]

  """Return a bunch of Users for a given array of id"""
  waiting: [User]

  """Return a bunch of Users for a given array of id"""
  willing: [User]
  invited: [Invited]

  """Get the Prices of an object"""
  price: Price

  """Return a participantRange: NumberInterval"""
  participantRange: IntInterval

  """The policy applied to know who is alloed to go to the waiting list"""
  mode: SportunityMode!

  """The kind of the Sportunity (private / public)"""
  kind: SportunityKind!

  """Images of the event"""
  images: [String]

  """
  The date when users in the willing list will move to the
        waiting list if we are in RANDOM mode
  """
  randomDate: DateTime

  """Return a ageRestriction: NumberInterval"""
  ageRestriction: IntInterval

  """The restriction on sex to participate to the event"""
  sexRestriction: SexRestriction

  """The sport information for a sportunity"""
  sport: SportunitySport

  """Beginning date of the sportunity"""
  beginning_date: DateTime!

  """Ending date of the sportunity"""
  ending_date: DateTime!
  survey: Survey

  """Sportunity cancelling date"""
  cancel_date: DateTime

  """Get the status of the sportunity for current User"""
  status(
    """ID of the sportunity wanted"""
    sportunityId: String

    """ID of the user to get his status"""
    userId: String
  ): String

  """Get the status of payments for sportunity"""
  paymentStatus: [SportunityPaymentStatus]

  """Fees to apply to organizers of this sportunity"""
  fees: Int
  creation_status: SportunityCreationStatus

  """Date of creation of the sportunity"""
  creation_date: DateTime

  """The list of all circles belonging to a given object"""
  invited_circles(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection
  price_for_circle: [PriceForCircle]
  notification_preference: SportunityNotificationPreferenceOutput

  """Preference of privacy switch"""
  privacy_switch_preference: PrivacySwitchPreferenceOutput

  """Occurence number if the sportunity is in a serie"""
  is_repeated_occurence_number: Int

  """
  Number of occurences in the serie if the actual sportunity is in a serie
  """
  number_of_occurences: Int

  """
  Set to true if organizer doesn't want to show the sportunity's participant list
  """
  hide_participant_list: Boolean

  """Get the sportunity type"""
  sportunityType: SportunityType

  """Get the sportunity type status"""
  sportunityTypeStatus: SportunityTypeStatus

  """Score of this sportunity"""
  score: Score

  """Return a boolean to tell if current user can vote"""
  canUserVoteForManOfTheGame: Boolean
  manOfTheGameVotes: [manOfTheGameVotes]

  """Return the car-poolings of a given sportunity"""
  carPoolings: [CarPooling]
  game_information: GameInformation

  """Get the Compositions of a user / event"""
  compositions: [CompositionOutput]

  """External reference"""
  externalReference: String
}

"""A connection to a list of items."""
type SportunityConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [SportunityEdge]

  """Total number of tags"""
  count: Int
}

"""Creation status of this sportunity"""
type SportunityCreationStatus {
  """The status of current sportunity"""
  status: ValidationStatus

  """Tells the reason of the current status"""
  reason: String
}

"""An edge in a connection."""
type SportunityEdge {
  """The item at the end of the edge"""
  node: Sportunity

  """A cursor for use in pagination"""
  cursor: String!
}

"""Represents a sportunity input type"""
input SportunityInput {
  """The title of the Sportunity"""
  title: String!

  """The description of the Sportunity"""
  description: String!

  """The address of the Sportunity"""
  address: AddressInput

  """The venue id of the Sportunity"""
  venue: String

  """The infrastructure id"""
  infrastructure: String

  """The slot id"""
  slot: String

  """The organizers of the Sportunity"""
  organizers: [OrganizerInput]!

  """List of pending organizers"""
  pendingOrganizers: [PendingOrganizerInput]

  """Payment method id of main organizer to pay secondary organizers"""
  secondaryOrganizersPaymentMethod: String

  """If main organizer wants to pay secondary organizers with his wallet"""
  secondaryOrganizersPaymentByWallet: Boolean

  """Selected sport, levels, positions and certificates"""
  sport: SportunitySportInput!

  """Number of times the sportunity has been shared"""
  nbShares: Int

  """The price of the Sportunity"""
  price: PriceInput

  """The participant range accepted for the Sportunity"""
  participantRange: IntIntervalInput!

  """If the organizer want to participate to the sportunity"""
  participants: ID

  """The mode of the Sportunity"""
  mode: SportunityMode!

  """The kind of the Sportunity (private / public)"""
  kind: SportunityKind!

  """The date when user in willing pass to waiting"""
  randomDate: String

  """The age interval allowed for the Sportunity"""
  ageRestriction: IntIntervalInput!

  """The sex restriction fro the Sportunity"""
  sexRestriction: SexRestriction

  """Beginning date of the sportunity"""
  beginning_date: String!

  """Ending date of the sportunity"""
  ending_date: String!

  """List of dates for a survey"""
  survey_dates: [SurveyDatesInput]

  """Sportunity's cancelling date"""
  cancel_date: String

  """Users who are invited to participate"""
  invited: [InvitedInput]

  """List of circles invited to join the sportunity"""
  invited_circles: [String]

  """Prices of the different invited circles"""
  price_for_circle: [InvitedCircleInput]

  """The card Id for a participant to pay"""
  paymentMethodId: ID

  """The number of times this sportunity will be repeated"""
  repeat: Int

  """
  Set to true if organizer doesn't want to show the sportunity's participant list
  """
  hide_participant_list: Boolean

  """Preference of notification type to send to invited users"""
  notification_preference: NotificationPreferenceInput

  """Preference of privacy switch"""
  privacy_switch_preference: PrivacySwitchPreferenceInput

  """Type of the event (regarding its sport)"""
  sportunityType: String

  """Information of the game : opponent, season, ... """
  game_information: GameInformationInput

  """External reference"""
  externalReference: String
}

"""Specifies which kind of sportunity it is"""
enum SportunityKind {
  """The sportuniy is public means that everyone can see it"""
  PUBLIC

  """The sportunity is private, only invited users can see it """
  PRIVATE
}

enum SportunityMode {
  """Everyone goes automatically to the waiting list and can pay now"""
  FCFS

  """
  Everyone goes to willing list and users will be moved to the waiting
          list at given time by a bot
  """
  RANDOM

  """
  Everyone goes to willing list and users will be moved to the waiting
          list by an organizer
  """
  ORGANIZER_PICK
}

enum SportunityNotificationPreference {
  """
  Send the notification to invited users as soon as the sportunity is created.
  """
  Now

  """
  Send the notification to invited users only when organizer asks for it.
  """
  Manually

  """
  Send the notification to invited users a few days (default 8 days) before sportunity's beginning.
  """
  Automatically
}

"""Preference of notification type to send to invited users"""
type SportunityNotificationPreferenceOutput {
  """Type of notification to send to invited users"""
  notification_type: SportunityNotificationPreference

  """
  If organizer wants to send the notification automatically x days before sportunity's beginning
  """
  send_notification_x_days_before: Int

  """Date of last notification post"""
  last_post: DateTime
}

"""Opponent of this game"""
input SportunityOpponentInput {
  """Id of the opponent organizer"""
  organizer: String

  """Email of the opponent organizer if he is not in our database"""
  organizerEmail: String

  """Pseudo of the opponent organizer if he is not in our database"""
  organizerPseudo: String

  """Id of the opponent sportunity"""
  event: String

  """Tells if the organizer is looking for an opponent"""
  lookingForAnOpponent: Boolean

  """Tells if the organizer doesn't know the opponent"""
  unknownOpponent: Boolean

  """List of circles that can create a match against current sportunity"""
  invitedOpponents: [String]
}

"""Opponent of this game"""
type SportunityOpponentOutput {
  """Return a Users for a given id"""
  organizer: User

  """Pseudo of the opponent if he is not in our database"""
  organizerPseudo: String

  """A Sportunity"""
  event(
    """ID of the sportunity wanted"""
    id: ID

    """External reference"""
    externalReference: String
  ): Sportunity

  """Tells if the organizer is looking for an opponent"""
  lookingForAnOpponent: Boolean

  """Tells if the organizer doesn't know the opponent"""
  unknownOpponent: Boolean

  """The list of all circles belonging to a given object"""
  invitedOpponents(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection
}

"""Opponent of this game"""
input SportunityOpponentUpdateInput {
  """Id of the opponent organizer"""
  organizer: String

  """Email of the opponent organizer if he is not in our database"""
  organizerEmail: String

  """Pseudo of the opponent organizer if he is not in our database"""
  organizerPseudo: String

  """Id of the opponent sportunity"""
  event: String

  """Tells if the organizer is looking for an opponent"""
  lookingForAnOpponent: Boolean

  """Tells if the organizer doesn't know the opponent"""
  unknownOpponent: Boolean

  """List of circles that can create a match against current sportunity"""
  invitedOpponents: [String]
}

"""status of the payment of sportunity for User"""
type SportunityPaymentStatus implements Node {
  """The ID of an object"""
  id: ID!

  """Return a Users for a given id"""
  user: User

  """Sportunity Payment Status"""
  status: PaymentStatus

  """Get the Prices of an object"""
  price: Price

  """Tells if the user wants to pay with his wallet"""
  paymentWithWallet: Boolean

  """The payment method the user choose for an event"""
  paymentMethod: PaymentMethod

  """Last update date"""
  updated: DateTime
}

enum SportunityPrivacySwitchPreference {
  """The organizer can manually change the privacy of the sportunity"""
  Manually

  """
  Kind of the sportunity will be changed automatically some days before sportunity begins
  """
  Automatically
}

"""The sport information for a sportunity"""
type SportunitySport {
  """Get a sport for object that have only one"""
  sport(
    """ID of the sport wanted"""
    id: ID
  ): Sport

  """Tells if all the sport's levels have been selected"""
  allLevelSelected: Boolean

  """Return a levels: TranslatedSportLevel"""
  levels: [Translated]

  """Return the certificates of a given object"""
  certificates: [Certificate]

  """Return a positions: TranslatedString"""
  positions: [TranslatedString]
}

"""Represents a sportunity's sport input"""
input SportunitySportInput {
  """Id of the sport"""
  sport: String!

  """Tells if all the sport's levels have been selected"""
  allLevelSelected: Boolean

  """Ids of the levels"""
  levels: [String]

  """List of certificates"""
  certificates: [String]

  """The positions the user plays in the sport"""
  positions: [String]
}

"""Represents a sportunity statistic input type"""
input SportunityStatisticInput {
  """Id of the statistic preference linked to this statistic"""
  statisticId: String

  """Id of the participant (null if the statistic if for the sportunity)"""
  participantId: String

  """Value of the current statistic"""
  value: Int
}

"""Status of an event, for the current user"""
enum SportunityStatus {
  """Filter available sportunities"""
  Available

  """Filter booked sportunities"""
  Booked

  """Filter organized sportunities"""
  Organized

  """Filter organized and booked sportunities"""
  MySportunities

  """Filter sporunities where user is invited"""
  Invited

  """Filter sportunities where user was invited but declined"""
  Declined

  """Filter past sportunities"""
  Past

  """Filter cancelled sportunities"""
  Cancelled

  """Filter co-organizer sportunities"""
  CoOrganizer

  """Filter asked co-organizer sportunities"""
  AskedCoOrganizer

  """Filter for surveys"""
  Survey
}

"""Represents a sportunity status input type"""
input SportunityStatusInput {
  """The current status of the sportunity"""
  status: ValidationStatus

  """The reason of current status"""
  reason: String
}

"""A sportunity template"""
type SportunityTemplate implements Node {
  """The ID of an object"""
  id: ID!

  """The title of the sportunity"""
  title: String

  """The description of the Sportunity"""
  description: String

  """The address of a user"""
  address: AddressModel

  """Get the list of organizers"""
  organizers: [Organizer]

  """Get the list of pending organizers"""
  pendingOrganizers: [PendingOrganizer]
  invited: [SportunityTemplateInvited]

  """Get the Prices of an object"""
  price: Price

  """Return a participantRange: NumberInterval"""
  participantRange: IntInterval

  """The policy applied to know who is alloed to go to the waiting list"""
  mode: SportunityMode!

  """The kind of the Sportunity (private / public)"""
  kind: SportunityKind!

  """Images of the event"""
  images: [String]

  """Return a ageRestriction: NumberInterval"""
  ageRestriction: IntInterval

  """The restriction on sex to participate to the event"""
  sexRestriction: SexRestriction

  """The sport information for a sportunity"""
  sport: SportunitySport

  """Fees to apply to organizers of this sportunity"""
  fees: Int

  """Date of creation of the sportunity"""
  creation_date: DateTime

  """The list of all circles belonging to a given object"""
  invited_circles(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection
  price_for_circle: [SportunityTemplatePriceForCircle]
  notification_preference: SportunityTemplateNotificationPreferenceOutput

  """Preference of privacy switch"""
  privacy_switch_preference: SportunityTemplatePrivacySwitchPreferenceOutput

  """Occurence number if the sportunity is in a serie"""
  is_repeated_occurence_number: Int

  """
  Number of occurences in the serie if the actual sportunity is in a serie
  """
  number_of_occurences: Int

  """
  Set to true if organizer doesn't want to show the sportunity's participant list
  """
  hide_participant_list: Boolean

  """Get the sportunity type"""
  sportunityType: SportunityType
  game_information: SportunityTemplateGameInformation
}

"""Who should be excluded from the invited list"""
type SportunityTemplateExcludedInvitees {
  """Statuses of members to exclude"""
  excludedStatus: [CircleMemberStatus]

  """Return a bunch of Users for a given array of id"""
  excludedMembers: [User]

  """Should this event invite parents"""
  excludeParents: Boolean
}

"""If participant by default = true, who should be excluded"""
type SportunityTemplateExcludedParticipantByDefault {
  """Statuses of members to exclude"""
  excludedStatus: [CircleMemberStatus]

  """Return a bunch of Users for a given array of id"""
  excludedMembers: [User]

  """Should this event include parents as participant by default"""
  excludeParents: Boolean
}

"""Information of the game : opponent, season, ... """
type SportunityTemplateGameInformation {
  """Information about the opponent"""
  opponent: SportunityTemplateOpponentOutput
}

"""Information of the game : opponent, season, ... """
input SportunityTemplateGameInformationInput {
  """Information about the opponent"""
  opponent: SportunityTemplateOpponentInput
}

"""Represents a sportunity input type"""
input SportunityTemplateInput {
  """The title of the Sportunity"""
  title: String!

  """The description of the Sportunity"""
  description: String!

  """The address of the Sportunity"""
  address: AddressInput

  """The organizers of the Sportunity"""
  organizers: [OrganizerInput]!

  """List of pending organizers"""
  pendingOrganizers: [PendingOrganizerInput]

  """Payment method id of main organizer to pay secondary organizers"""
  secondaryOrganizersPaymentMethod: String

  """If main organizer wants to pay secondary organizers with his wallet"""
  secondaryOrganizersPaymentByWallet: Boolean

  """Selected sport, levels, positions and certificates"""
  sport: SportunitySportInput!

  """The price of the Sportunity"""
  price: PriceInput

  """The participant range accepted for the Sportunity"""
  participantRange: IntIntervalInput!

  """The mode of the Sportunity"""
  mode: SportunityMode!

  """The kind of the Sportunity (private / public)"""
  kind: SportunityKind!

  """The age interval allowed for the Sportunity"""
  ageRestriction: IntIntervalInput!

  """The sex restriction fro the Sportunity"""
  sexRestriction: SexRestriction

  """Users who are invited to participate"""
  invited: [InvitedInput]

  """List of circles invited to join the sportunity"""
  invited_circles: [String]

  """Prices of the different invited circles"""
  price_for_circle: [InvitedCircleInput]

  """
  Set to true if organizer doesn't want to show the sportunity's participant list
  """
  hide_participant_list: Boolean

  """Preference of notification type to send to invited users"""
  notification_preference: SportunityTemplateNotificationPreferenceInput

  """Preference of privacy switch"""
  privacy_switch_preference: SportunityTemplatePrivacySwitchPreferenceInput

  """Type of the event (regarding its sport)"""
  sportunityType: String

  """Information of the game : opponent, season, ... """
  game_information: SportunityTemplateGameInformationInput
}

"""Represent a user invited to a Sportunity"""
type SportunityTemplateInvited {
  """Return a Users for a given id"""
  user: User

  """Tells the answer of the invited user"""
  answer: invitedUserAnswer
}

"""Represents a notification type input"""
input SportunityTemplateNotificationPreferenceInput {
  """Type of notification to send to invited users"""
  notification_type: SportunityNotificationPreference

  """
  If organizer wants to send the notification automatically x days before sportunity's beginning
  """
  send_notification_x_days_before: Int
}

"""Preference of notification type to send to invited users"""
type SportunityTemplateNotificationPreferenceOutput {
  """Type of notification to send to invited users"""
  notification_type: SportunityNotificationPreference

  """
  If organizer wants to send the notification automatically x days before sportunity's beginning
  """
  send_notification_x_days_before: Int

  """Date of last notification post"""
  last_post: DateTime
}

"""Opponent of this game"""
input SportunityTemplateOpponentInput {
  """Id of the opponent organizer"""
  organizer: String

  """Email of the opponent organizer if he is not in our database"""
  organizerEmail: String

  """Pseudo of the opponent organizer if he is not in our database"""
  organizerPseudo: String

  """Id of the opponent sportunity"""
  event: String

  """Tells if the organizer is looking for an opponent"""
  lookingForAnOpponent: Boolean

  """Tells if the organizer doesn't know the opponent"""
  unknownOpponent: Boolean

  """List of circles that can create a match against current sportunity"""
  invitedOpponents: [String]
}

"""Opponent of this game"""
type SportunityTemplateOpponentOutput {
  """Return a Users for a given id"""
  organizer: User

  """Pseudo of the opponent if he is not in our database"""
  organizerPseudo: String

  """Tells if the organizer is looking for an opponent"""
  lookingForAnOpponent: Boolean

  """Tells if the organizer doesn't know the opponent"""
  unknownOpponent: Boolean

  """The list of all circles belonging to a given object"""
  invitedOpponents(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection
}

"""Prices for invited circles"""
type SportunityTemplatePriceForCircle {
  """A circle"""
  circle(
    """ID of the circle wanted"""
    id: ID

    """Code to invit a member or a circle in a private circle"""
    code: String
  ): Circle

  """Get the Prices of an object"""
  price: Price

  """
  Tells if members of the current circle should be participants by default (for free sportunities only)
  """
  participantByDefault: Boolean

  """If participant by default = true, who should be excluded"""
  excludedParticipantByDefault: SportunityTemplateExcludedParticipantByDefault

  """Who should be excluded from the invited list"""
  excludedInvitees: SportunityTemplateExcludedInvitees
}

"""
Represents the preference of the organizer for privacy switching of the sportunity
"""
input SportunityTemplatePrivacySwitchPreferenceInput {
  """Type of switch to change from private to public the sportunity"""
  privacy_switch_type: SportunityPrivacySwitchPreference

  """
  If organizer wants to switch the kind from private to public automatically x days before sportunity's beginning
  """
  switch_privacy_x_days_before: Int
}

"""
Represents the preference of the organizer for privacy switching of the sportunity
"""
type SportunityTemplatePrivacySwitchPreferenceOutput {
  """Type of switch to change from private to public the sportunity"""
  privacy_switch_type: SportunityPrivacySwitchPreference

  """
  If organizer wants to switch the kind from private to public automatically x days before sportunity's beginning
  """
  switch_privacy_x_days_before: Int
}

"""An event type, regarding its sport"""
type SportunityType implements Node {
  """The ID of an object"""
  id: ID!

  """Return a name: TranslatedString"""
  name: TranslatedString

  """Get the available status for a type of event for a sport"""
  statuses: [SportunityTypeStatus]

  """Tells if a score can be set on this sportunity type"""
  isScoreRelevant: Boolean
}

"""An event type status, regarding its sport"""
type SportunityTypeStatus implements Node {
  """The ID of an object"""
  id: ID!

  """Return a name: TranslatedString"""
  name: TranslatedString
}

"""Represents a sportunity input type"""
input SportunityUpdateInput {
  """The title of the Sportunity"""
  title: String

  """The description of the Sportunity"""
  description: String

  """The address of the Sportunity"""
  address: AddressInput

  """The venue id of the Sportunity"""
  venue: String

  """The infrastructure id"""
  infrastructure: String

  """The slot id"""
  slot: String
  organizers: [OrganizerInput]

  """List of pending organizers"""
  pendingOrganizers: [PendingOrganizerInput]

  """Payment method id of main organizer to pay secondary organizers"""
  secondaryOrganizersPaymentMethod: String

  """If main organizer wants to pay secondary organizers with his wallet"""
  secondaryOrganizersPaymentByWallet: Boolean

  """Selected sport, levels, positions and certificates"""
  sport: SportunitySportInput

  """Number of times the sportunity has been shared"""
  nbShares: Int

  """The price of the Sportunity"""
  price: PriceInput

  """The participant range accepted for the Sportunity"""
  participantRange: IntIntervalInput

  """The mode of the Sportunity"""
  mode: SportunityMode

  """The kind of the Sportunity (private / public)"""
  kind: SportunityKind

  """The date when user in willing pass to waiting"""
  randomDate: String

  """The age interval allowed for the Sportunity"""
  ageRestriction: IntIntervalInput

  """The sex restriction fro the Sportunity"""
  sexRestriction: SexRestriction

  """Beginning date of the sportunity"""
  beginning_date: String

  """Ending date of the sportunity"""
  ending_date: String

  """List of dates for a survey"""
  survey_dates: [SurveyDatesUpdateInput]

  """Sportunity's cancelling date"""
  cancel_date: String

  """Fees to apply to organizers of this sportunity"""
  fees: Int

  """Users who are going to participate"""
  participants: ID

  """Users who wants to cancel his booking"""
  canceling: ID

  """Cancelation reason -> id of the stat"""
  canceling_reason: ID

  """Users who are invited to participate"""
  invited: [InvitedInput]

  """List of circle Ids invited to join the sportunity"""
  invited_circles: [String]

  """Prices of the different invited circles"""
  price_for_circle: [InvitedCircleInput]

  """The status of current venue"""
  creation_status: SportunityStatusInput

  """The card Id for a participant to pay"""
  paymentMethodId: ID

  """Tells if the booker wants to pay with his wallet"""
  paymentByWallet: Boolean

  """Preference of notification type to send to invited users"""
  notification_preference: NotificationPreferenceUpdateInput

  """Preference of privacy switch"""
  privacy_switch_preference: PrivacySwitchPreferenceUpdateInput

  """Tells if repeated sportunities must be modified too"""
  modifyRepeatedSportunities: Boolean

  """
  Set to true if organizer doesn't want to show the sportunity's participant list
  """
  hide_participant_list: Boolean

  """Type of the event (regarding its sport)"""
  sportunityType: String

  """Status of the event (regarding its sportunityType)"""
  sportunityTypeStatus: String

  """Score of this sportunity"""
  score: ScoreInput

  """Information of the game : opponent, season, ... """
  game_information: GameInformationUpdateInput

  """External reference"""
  externalReference: String
}

"""Represents a sport input type"""
input SportUpdateInput {
  """The name of the sport in different langauges"""
  name: StringTranslatedInput

  """The logo for this sport in SVG format"""
  logo: String

  """The list of postions in different langauges"""
  positions: [StringTranslatedInput]

  """The list of certicates"""
  certificates: [CertificateInput]

  """The list of the levels in different langauges"""
  levels: [SportLevelInputTranslatedInput]

  """Tells if the sport is active or not"""
  status: status

  """Type of this sport"""
  type: SportTypeEnum

  """Images of the field"""
  fieldImages: [String]
}

"""Statistic"""
type Statistic {
  """Get the current statistic"""
  statisticName: StatisticName

  """A Sportunity"""
  sportunity(
    """ID of the sportunity wanted"""
    id: ID

    """External reference"""
    externalReference: String
  ): Sportunity

  """Return a Users for a given id"""
  participant: User

  """Value of the statistic"""
  value: Int

  """Tells if the current stat is about availability"""
  isAvailabilityStat: Boolean
}

"""Creation status of this sportunity"""
type StatisticDetails {
  """Return a Users for a given id"""
  opponent: User

  """Value of this stat for opponent"""
  value: Int
}

"""Statistic filter"""
type StatisticFilter {
  """The ID of an object"""
  id: ID!

  """Name of the statistic filter"""
  name: String

  """Beginning date of the filter"""
  date_begin: DateTime

  """Ending date of the filter"""
  date_end: DateTime

  """The list of all circles belonging to a given object"""
  circleList(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection
}

"""Statistic name"""
type StatisticName {
  """The ID of an object"""
  id: ID!

  """Name of the statistic"""
  name: String
}

"""Statistic preferences for the current user"""
type StatisticPreferences {
  """Tells if the user's stats are private or public"""
  private: Boolean

  """Tells if the user activated man of the game statistics"""
  isManOfTheGameActivated: Boolean
  userStats: userStats
  availabilityStats: availabilityStats
}

"""Represents a statistic preferences input type"""
input StatisticPreferencesInput {
  """Defines if those statistics are private or public"""
  private: Boolean

  """Tells if the user activated man of the game statistics"""
  isManOfTheGameActivated: Boolean

  """Represent a user's preference for his participant's stats"""
  userStats: UserStatsPrefsInput

  """Represent a user's preference for his participant's availability"""
  availabilityStats: UserAvailabilityStatsPrefsInput
}

"""List of available status for sports"""
enum status {
  """The sport is valid, users can see it"""
  ACTIVE

  """Only admin users can see DELETED sports"""
  DELETED
}

"""Represent an interval of String"""
type StringInterval {
  """The lower bound of the interval"""
  from: String

  """The upper bound of the interval"""
  to: String
}

"""Represent an interval input of String"""
input StringIntervalInput {
  """The lower bound of the interval"""
  from: String!

  """The upper bound of the interval"""
  to: String!
}

"""Represent a translated String"""
input StringTranslatedInput {
  """The translation for this string in FR"""
  FR: String

  """The translation for this string in EN"""
  EN: String

  """The translation for this string in DE"""
  DE: String

  """The translation for this string in ES"""
  ES: String
}

"""List of sub accounts with corresponding tokens"""
type SubAccounts {
  """Id"""
  id: String

  """Pseudo"""
  pseudo: String

  """Avatar"""
  avatar: String

  """Gives the number of unread notifications for this user"""
  numberOfUnreadNotifications: Int

  """Gives the number of unread chats for this user"""
  unreadChats: Int

  """Token for this user"""
  token: String
}

type Subscription {
  addMsgSubscription(input: addMsgSubscriptionInput!): addMsgSubscriptionPayload
  unreadChatsSubscription(input: unreadChatsSubscriptionInput!): unreadChatsSubscriptionPayload
  newNotificationSubscription(input: newNotificationSubscriptionInput!): newNotificationSubscriptionPayload
  unreadNotificationsSubscription(input: unreadNotificationsSubscriptionInput!): unreadNotificationsSubscriptionPayload
  updateSportunitySubscription(input: updateSportunitySubscriptionInput!): updateSportunitySubscriptionPayload
  updateUserSubscription(input: updateUserSubscriptionInput!): updateUserSubscriptionPayload
}

"""Super user object"""
type SuperUser {
  """Id of the super user"""
  id: String

  """Pseudo of the super user"""
  pseudo: String

  """Avatar of the super user"""
  avatar: String

  """Tells if current user is already a subaccount"""
  isSubAccount: Boolean

  """The type of the super user"""
  profileType: UserProfileType

  """The user preferences"""
  userPreferences: SuperUserPreferences

  """Gives the number of unread notifications for this user"""
  numberOfUnreadNotifications: Int

  """Gives the number of unread chats for this user"""
  unreadChats: Int

  """List of sub accounts with corresponding tokens"""
  subAccounts: [SubAccounts]
}

"""The user preferences"""
type SuperUserPreferences {
  """Allow the user to create sub-accounts if activated"""
  areSubAccountsActivated: Boolean
}

"""Represent any language Sportunity supports"""
enum supportedCountries {
  AF
  AX
  AL
  DZ
  AS
  AD
  AO
  AI
  AQ
  AG
  AR
  AM
  AW
  AU
  AT
  AZ
  BS
  BH
  BD
  BB
  BY
  BE
  BZ
  BJ
  BM
  BT
  BO
  BQ
  BA
  BW
  BV
  BR
  IO
  BN
  BG
  BF
  BI
  KH
  CM
  CA
  CV
  KY
  CF
  TD
  CL
  CN
  CX
  CC
  CO
  KM
  CG
  CD
  CK
  CR
  CI
  HR
  CU
  CW
  CY
  CZ
  DK
  DJ
  DM
  DO
  EC
  EG
  SV
  GQ
  ER
  EE
  ET
  FK
  FO
  FJ
  FI
  FR
  GF
  PF
  TF
  GA
  GM
  GE
  DE
  GH
  GI
  GR
  GL
  GD
  GP
  GU
  GT
  GG
  GN
  GW
  GY
  HT
  HM
  VA
  HN
  HK
  HU
  IS
  IN
  ID
  IR
  IQ
  IE
  IM
  IL
  IT
  JM
  JP
  JE
  JO
  KZ
  KE
  KI
  KP
  KR
  KW
  KG
  LA
  LV
  LB
  LS
  LR
  LY
  LI
  LT
  LU
  MO
  MK
  MG
  MW
  MY
  MV
  ML
  MT
  MH
  MQ
  MR
  MU
  YT
  MX
  FM
  MD
  MC
  MN
  ME
  MS
  MA
  MZ
  MM
  NA
  NR
  NP
  NL
  NC
  NZ
  NI
  NE
  NG
  NU
  NF
  MP
  NO
  OM
  PK
  PW
  PS
  PA
  PG
  PY
  PE
  PH
  PN
  PL
  PT
  PR
  QA
  RE
  RO
  RU
  RW
  BL
  SH
  KN
  LC
  MF
  PM
  VC
  WS
  SM
  ST
  SA
  SN
  RS
  SC
  SL
  SG
  SX
  SK
  SI
  SB
  SO
  ZA
  GS
  SS
  ES
  LK
  SD
  SR
  SJ
  SZ
  SE
  CH
  SY
  TW
  TJ
  TZ
  TH
  TL
  TG
  TK
  TO
  TT
  TN
  TR
  TM
  TC
  TV
  UG
  UA
  AE
  GB
  US
  UM
  UY
  UZ
  VU
  VE
  VN
  VG
  VI
  WF
  EH
  YE
  ZM
  ZW
}

"""Represent any language Sportunity supports"""
enum SupportedLanguage {
  FR
  EN
  DE
  ES
}

type Survey {
  """Tells if the survey has been transformed to an event"""
  isSurveyTransformed: Boolean

  """List of dates for a survey"""
  surveyDates: [SurveyDatesOutput]
}

"""Represent a user invited to a Sportunity"""
type SurveyAnswer {
  """Return a Users for a given id"""
  user: User

  """Tells the answer of the invited user"""
  answer: invitedUserAnswer
}

"""Represents a date for a survey"""
input SurveyDatesInput {
  """Beginning date of the proposition"""
  beginning_date: String

  """Ending date of the proposition"""
  ending_date: String
}

"""Represents a date for a survey"""
type SurveyDatesOutput {
  """Beginning date of the proposition"""
  beginning_date: String

  """Ending date of the proposition"""
  ending_date: String

  """List of answers"""
  answers: [SurveyAnswer]
}

"""Represents a date for a survey"""
input SurveyDatesUpdateInput {
  """Beginning date of the proposition"""
  beginning_date: String

  """Ending date of the proposition"""
  ending_date: String
}

input SurveyInvitedAnswers {
  """The beginning date of the proposition"""
  beginning_date: String

  """The ending date of the proposition"""
  ending_date: String

  """Answer to the survey"""
  answer: invitedUserAnswer!
}

type TermsOfUseAcceptedBy {
  """Return a Users for a given id"""
  user: User

  """Date of user acceptation"""
  acceptedDate: DateTime
}

"""Total amount on the wallet"""
type TotalAmountOnWallet {
  """The currency in which this amount was set"""
  currency: Currency

  """The amount on current user's wallet"""
  cents: Int
}

"""Transaction object"""
type Transaction {
  """The ID of an object"""
  id: ID!

  """Return a Users for a given id"""
  from: User

  """Return a Users for a given id"""
  to: User

  """Date of creation"""
  creation_date: DateTime
  updates: [Updates]

  """Kind of the transaction"""
  kind: TransactionKind

  """Actual status of the transaction"""
  status: TransactionStatus
  reason: TransactionReason

  """Get the Prices of an object"""
  amount: Price
  paymentWith: PaymentWith
}

"""A connection to a list of items."""
type TransactionConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TransactionEdge]

  """Total number of tags"""
  count: Int
}

"""An edge in a connection."""
type TransactionEdge {
  """The item at the end of the edge"""
  node: Transaction

  """A cursor for use in pagination"""
  cursor: String!
}

"""Filter the transactions"""
input TransactionFilter {
  """Filter by status"""
  transactionStatus: TransactionStatus

  """Filter by kind"""
  transactionKinds: [TransactionKind]

  """Id of users to get their transactions"""
  users: [String]
}

"""Type of a transaction"""
enum TransactionKind {
  """Cash In"""
  CASH_IN

  """Transfert"""
  TRANSFERT

  """Cash out"""
  CASH_OUT

  """Refund"""
  REFUND

  """Fees for Sportunity"""
  FEES
}

"""Method of a transaction"""
enum TransactionMethod {
  """Bank wire"""
  BANKWIRE

  """Wallet"""
  WALLET

  """Credit card"""
  CREDIT_CARD
}

"""Reason of the transaction"""
type TransactionReason {
  """A Sportunity"""
  sportunity(
    """ID of the sportunity wanted"""
    id: ID

    """External reference"""
    externalReference: String
  ): Sportunity

  """Payment model"""
  paymentModel: CirclePaymentModel
}

"""Status of a transaction"""
enum TransactionStatus {
  """Waiting for creation"""
  TO_COME

  """Creation"""
  CREATION

  """To be done"""
  TO_BE_DONE

  """Done"""
  DONE

  """Cancelled"""
  CANCELLED

  """Error"""
  ERROR
}

"""Represent a translated """
type Translated {
  """The ID of an object"""
  id: ID!

  """Get a SporLevel"""
  FR: SportLevel

  """Get a SporLevel"""
  EN: SportLevel

  """Get a SporLevel"""
  DE: SportLevel

  """Get a SporLevel"""
  ES: SportLevel
}

"""Represent a translated String"""
type TranslatedString {
  """The ID of an object"""
  id: ID!

  """The translation for this string in FR"""
  FR: String

  """The translation for this string in EN"""
  EN: String

  """The translation for this string in DE"""
  DE: String

  """The translation for this string in ES"""
  ES: String
}

"""Tells which tutorial steps are done by the user"""
type TutorialSteps {
  """Step to setup administrative forms"""
  createFormStep: Boolean

  """Step to send the exact money to be paid by your members"""
  setupMembersSubscriptionStep: Boolean

  """Step to fulfil your profile"""
  fulfilProfileStep: Boolean

  """Step to make your members accept any document"""
  addOfficialDocumentsStep: Boolean

  """Step to create subaccounts"""
  createSubAccountStep: Boolean

  """Step to share account access"""
  shareAccessStep: Boolean

  """Step to create a circle"""
  createCircleStep: Boolean

  """Step to organize a sportunity"""
  organizeStep: Boolean

  """Step to setup the statistics"""
  setupStatisticsStep: Boolean

  """Step to join a private group"""
  joinAPrivateCircleStep: Boolean

  """Step to join a public group"""
  joinAPublicCircleStep: Boolean

  """Step to give availabilities"""
  giveAvailabilitiesStep: Boolean

  """Step to book a sportunity"""
  bookSportunityStep: Boolean
}

"""Tutorial steps done by the user"""
input TutorialStepsInput {
  """Step to setup administrative forms"""
  createFormStep: Boolean

  """Step to send the exact money to be paid by your members"""
  setupMembersSubscriptionStep: Boolean

  """Step to fulfil your profile"""
  fulfilProfileStep: Boolean

  """Step to make your members accept any document"""
  addOfficialDocumentsStep: Boolean

  """Step to create subaccounts"""
  createSubAccountStep: Boolean

  """Step to share account access"""
  shareAccessStep: Boolean

  """Step to create a circle"""
  createCircleStep: Boolean

  """Step to organize a sportunity"""
  organizeStep: Boolean

  """Step to setup the statistics"""
  setupStatisticsStep: Boolean

  """Step to join a private group"""
  joinAPrivateCircleStep: Boolean

  """Step to join a public group"""
  joinAPublicCircleStep: Boolean

  """Step to give availabilities"""
  giveAvailabilitiesStep: Boolean

  """Step to book a sportunity"""
  bookSportunityStep: Boolean
}

input unfollowUserInput {
  """Id of the user to unfollow"""
  userID: String
  clientMutationId: String
}

type unfollowUserPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input unreadChatsSubscriptionInput {
  clientSubscriptionId: String
}

type unreadChatsSubscriptionPayload {
  unreadChats: Int
  user: User
  viewer: Viewer
  clientSubscriptionId: String
}

input unreadNotificationsSubscriptionInput {
  clientSubscriptionId: String
}

type unreadNotificationsSubscriptionPayload {
  unreadNotifications: Int
  user: User
  viewer: Viewer
  clientSubscriptionId: String
}

input updateAskedInformationFormInput {
  id: String
  name: String!
  circleIds: [String]!
  customFieldsIds: [String]
  customFields: [customFieldsInput]
  askedInformation: [AskedInformationInput]
  clientMutationId: String
}

type updateAskedInformationFormPayload {
  viewer: Viewer
  clientMutationId: String
}

input updateAskedInformationInput {
  circleId: String!
  askedInformation: [AskedInformation]
  clientMutationId: String
}

type updateAskedInformationPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input updateAssistantTypeInput {
  """ID of the assistant type to update"""
  assistantTypeID: String!

  """The translation for the updated assistant type linked to a sport"""
  name: StringTranslatedInput
  clientMutationId: String
}

type updateAssistantTypePayload {
  assistantType: AssistantType
  viewer: Viewer
  clientMutationId: String
}

input updateCarPoolingInput {
  """The ID of the sportunity"""
  sportunityID: String!

  """The ID of the car-pooling to update"""
  carPoolingID: String!

  """Car pooling input type"""
  carPooling: CarPoolingInput
  clientMutationId: String
}

type updateCarPoolingPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input updateCircleInput {
  """The ID of the circle to update"""
  circleId: String!

  """A Circle input type"""
  circle: CircleInput
  clientMutationId: String
}

input updateCircleMemberStatusInput {
  circleId: String!
  memberStatus: [MemberStatusInput]
  clientMutationId: String
}

type updateCircleMemberStatusPayload {
  edge: CircleEdge
  circle: Circle
  viewer: Viewer
  clientMutationId: String
}

type updateCirclePayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input updateCirclePaymentModelInput {
  paymentModel: CirclePaymentModelInput
  clientMutationId: String
}

type updateCirclePaymentModelPayload {
  viewer: Viewer
  clientMutationId: String
}

input updateCirclesInPrivateModeInput {
  """The ID of the circle to update"""
  circleId: String!

  """The IDs of the circles from private mode to update"""
  circleIds: [String]!
  clientMutationId: String
}

type updateCirclesInPrivateModePayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input updateCircleTermsOfUseInput {
  termsOfUse: CircleTermsOfUseInput
  clientMutationId: String
}

type updateCircleTermsOfUsePayload {
  viewer: Viewer
  termsOfUse: CircleTermsOfUse
  clientMutationId: String
}

input updateCompositionInput {
  """The ID of the composition to update"""
  compositionId: String

  """A User input type"""
  composition: CompositionInput
  clientMutationId: String
}

type updateCompositionPayload {
  user: User
  composition: CompositionOutput
  viewer: Viewer
  clientMutationId: String
}

input updateDescriptionInput {
  """title of sportunity to update"""
  description: String!

  """The IDs of the sportunities to update"""
  sportunityIDs: [String]!
  clientMutationId: String
}

type updateDescriptionPayload {
  viewer: Viewer
  clientMutationId: String
}

input updateFilledInformationInput {
  circleId: String!
  answers: [Answers]
  clientMutationId: String
}

type updateFilledInformationPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input updateInfrastructureInput {
  infrastructure: InfrastructureInput
  clientMutationId: String
}

type updateInfrastructurePayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

input updatePasswordInput {
  """Old password, that will be changed by new password"""
  oldPassword: String!

  """New password"""
  newPassword: String!
  clientMutationId: String
}

type updatePasswordPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

"""Represent a the list of updates for a transaction"""
type Updates {
  """Date of status change"""
  date: DateTime

  """Status before the update"""
  status_from: TransactionStatus

  """Status after the update"""
  status_to: TransactionStatus
}

input updateSlotInput {
  slot: SlotInput

  """Tells if the serie of slot should be updated"""
  updateSlotSerie: Boolean
  clientMutationId: String
}

type updateSlotPayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

input updateSportInput {
  """The ID of the sport to update"""
  sportID: String!

  """a Sport input type"""
  sport: SportUpdateInput
  clientMutationId: String
}

type updateSportPayload {
  edge: SportEdge
  viewer: Viewer
  clientMutationId: String
}

input updateSportunityCompositionsInput {
  """The ID of the sportunity to update"""
  sportunityId: String

  """The IDs of the composition to assign"""
  compositionIds: [String]
  clientMutationId: String
}

type updateSportunityCompositionsPayload {
  edge: SportunityEdge
  viewer: Viewer
  sportunity: Sportunity
  clientMutationId: String
}

input updateSportunityInput {
  """The ID of the sportunity to update"""
  sportunityID: String!

  """A Sportunity input type"""
  sportunity: SportunityUpdateInput

  """Tells if participants & invitees should be notified for this change"""
  notify_people: Boolean
  clientMutationId: String
}

type updateSportunityPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input updateSportunityStatisticsInput {
  """ID of the sportunity"""
  sportunityID: String!

  """Statistics for the sportunity"""
  sportunityStatistics: [SportunityStatisticInput]
  clientMutationId: String
}

type updateSportunityStatisticsPayload {
  sportunityStatistics: [Statistic]
  viewer: Viewer
  clientMutationId: String
}

input updateSportunitySubscriptionInput {
  """The ID of the sportunity to subscribe to"""
  sportunityId: String
  clientSubscriptionId: String
}

type updateSportunitySubscriptionPayload {
  sportunity: Sportunity
  viewer: Viewer
  clientSubscriptionId: String
}

input updateSportunityTemplateInput {
  """Id of the template to update"""
  sportunityTemplateId: String!

  """A Sportunity template input type"""
  sportunityTemplate: SportunityTemplateInput
  clientMutationId: String
}

type updateSportunityTemplatePayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input updateSportunityTypeInput {
  """ID of the sportunity type to update"""
  sportunityTypeID: String!

  """The translation for the updated type for an event linked to a sport"""
  name: StringTranslatedInput

  """Tells if a score can be set on this sportunity type"""
  isScoreRelevant: Boolean
  clientMutationId: String
}

type updateSportunityTypePayload {
  sportunityType: SportunityType
  viewer: Viewer
  clientMutationId: String
}

input updateSportunityTypeStatusInput {
  """ID of the sportunity type status to udpate"""
  sportunityTypeStatusID: String!

  """
  The translation of updated status for a type for an event linked to a sport
  """
  name: StringTranslatedInput!
  clientMutationId: String
}

type updateSportunityTypeStatusPayload {
  sportunityTypeStatus: SportunityTypeStatus
  viewer: Viewer
  clientMutationId: String
}

input updateStatisticFilterInput {
  """Id of the filter to update"""
  statisticFilterId: String!

  """Name of the filter"""
  name: String!

  """Beginning date of the filter"""
  date_begin: String

  """Ending date of the filter"""
  date_end: String

  """List of circles of the filter"""
  circleList: [String]
  clientMutationId: String
}

type updateStatisticFilterPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input updateStatisticPreferencesInput {
  """Statistic preferences input type"""
  statisticPreferences: StatisticPreferencesInput

  """ID of the user"""
  userID: String!
  clientMutationId: String
}

type updateStatisticPreferencesPayload {
  statisticPreferences: StatisticPreferences
  viewer: Viewer
  clientMutationId: String
}

input updateTimeInput {
  """beginning date of sportunity"""
  beginning_date: DateTime

  """ending date of sportunity"""
  ending_date: DateTime

  """The IDs of the sportunities to update"""
  sportunityIDs: [String]!
  clientMutationId: String
}

type updateTimePayload {
  viewer: Viewer
  clientMutationId: String
}

input updateTitleInput {
  """title of sportunity to update"""
  title: String!

  """The IDs of the sportunities to update"""
  sportunityIDs: [String]!
  clientMutationId: String
}

type updateTitlePayload {
  viewer: Viewer
  clientMutationId: String
}

input updateTutorialStepInput {
  """The ID of the user to update"""
  userID: String!

  """Tutorial steps done by the user"""
  tutorialSteps: TutorialStepsInput
  clientMutationId: String
}

type updateTutorialStepPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

"""Represents a user update input type"""
input UpdateUserInput {
  """First name of the user"""
  firstName: String

  """Last name of the user"""
  lastName: String

  """The unique pseudo of the user"""
  pseudo: String

  """The unique email of the user"""
  email: Email

  """The password of the user"""
  password: String

  """Country of the user"""
  appCountry: supportedCountries

  """Currency of the user"""
  appCurrency: Currency

  """List of language ids spoken by the current user"""
  languages: [String]

  """The language of user's app"""
  appLanguage: SupportedLanguage

  """Description of the user"""
  description: String

  """The avatar url ot the user"""
  avatar: String

  """The ids of the users which are blacklisted"""
  blackList: [String]

  """The id of the user who wants to follow current User"""
  followers: String

  """The phone prefix of the user"""
  phonePrefix: Int

  """The phone number of the user"""
  phoneNumber: Int

  """Birthday of the user"""
  birthday: String

  """If the user decides not to show his age to other users"""
  hideMyAge: Boolean

  """The gender of the user"""
  sex: Sex

  """Address of the user"""
  address: AddressInput

  """Public address of the user"""
  publicAddress: AddressInput

  """Fees to apply to user if he organizes a sportunity (20% -> 20)"""
  fees: Int

  """Fees to apply to user if he creates a payment model (3% -> 3)"""
  paymentModelFees: Int

  """List of sports that the user plays"""
  sports: [SportDescriptorInput]

  """The type of user"""
  profileType: UserProfileType

  """Tells if the user has a validated email address"""
  isEmailValidated: Boolean

  """to validate or not his public activities"""
  isTrustedUserToCreateActivities: Boolean

  """to validate or not his public groups"""
  isTrustedUserToCreateCircles: Boolean

  """The status of current user"""
  creation_status: UserStatusInput

  """Add a new Feedback to the user"""
  feedbacks: [FeedbackInput]

  """Save a filter"""
  savedFilters: [UserFilterInput]

  """Save a circle filter"""
  savedCircleFilters: [SavedCircleFilterInput]

  """Tells if the basic filters have been created"""
  basicSavedFiltersCreated: Boolean

  """Tells if the basic circle filters have been created"""
  basicCircleSavedFiltersCreated: Boolean

  """The users nationality"""
  nationality: String

  """User's occupation, ie. Work"""
  occupation: String

  """
  Could be only one of these values: 
                1 - for incomes <18K), 
                2 - for incomes between 18 and 30K, 
                3 - for incomes between 30 and 50K, 
                4 - for incomes between 50 and 80K, 
                5 - for incomes between 80 and 120K, 
                6 - for incomes >120K
  """
  incomeRange: Int

  """If the user is a business, then those fields are needed"""
  business: BusinessInput

  """Tells if the user has to declare VAT"""
  shouldDeclareVAT: Boolean
  authorized_managers: [AuthorizedManagerInput]

  """List of sportunities or users the current user added to his calendar"""
  calendar: CalendarInput

  """Let the user choose if he wants to receive notifications"""
  notification_preferences: NotificationPreferencesInput

  """Let the user choose if he wants to receive emails"""
  email_preferences: EmailPreferencesInput

  """Tells if the user activated his statistics module"""
  areStatisticsActivated: Boolean

  """
  Tells if the user activated the availability statistics for his participants
  """
  areAvailabilityStatisticsActivated: Boolean

  """Tells if the user activated the terms of use for his circles"""
  areTermsOfUseActivated: Boolean

  """Tells if the user activated his compositions module"""
  areCompositionsActivated: Boolean

  """Tells the prefered page when user logs in"""
  homePagePreference: HomePagePreference

  """The user preferences"""
  userPreferences: UserPreferencesInput
}

input updateUserSubscriptionInput {
  """The ID of the user to subscribe to"""
  userId: String
  clientSubscriptionId: String
}

type updateUserSubscriptionPayload {
  user: User
  viewer: Viewer
  clientSubscriptionId: String
}

input updateVenueInput {
  """The ID of the venue to update"""
  venueId: String

  """A Venue update input type"""
  venue: VenueUpdateInput
  clientMutationId: String
}

type updateVenuePayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

input upUserInput {
  """The ID of the user to update"""
  userID: String

  """Token to change password"""
  token: String

  """A User input type"""
  user: UpdateUserInput
  clientMutationId: String
}

type upUserPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

"""A Sportunity User"""
type User implements Node {
  """The ID of an object"""
  id: ID!

  """The token of the user"""
  token: String!

  """
  The first name of the user.
  
          Auth: Restricted
          
  """
  firstName: String

  """
  The last name of the user.
  
          Auth: Restricted
          
  """
  lastName: String

  """
  The pseudo of the user
  
      Example: blop
      
      Auth: Public
  """
  pseudo: String!

  """
  The email of the user
  
          Auth: Private
        
  """
  email: Email

  """
  The avatar link of the user
  
        Auth: Private
        
  """
  avatar: String

  """Inform if the profile is complete considering the user's type"""
  isProfileComplete: Boolean

  """Inform if the public profile is complete considering the user's type"""
  isPublicProfileComplete: Boolean

  """Return a bunch of Users for a given array of id"""
  blackList: [User]

  """Return a bunch of Users for a given array of id"""
  followers: [User]

  """Return the list of languages the current user speaks"""
  languages: [Language]

  """The language of user's app"""
  appLanguage: SupportedLanguage

  """Country of the user"""
  appCountry: supportedCountries

  """Currency of the user"""
  appCurrency: Currency

  """Description of the user"""
  description: String

  """
  The country prefix of the user's phone
  
        Example: 41
  
        Auth: Restricted
        
  """
  phonePrefix: Int

  """
  The country phone number of the user. What comes after the prefix
  
        Example: 789757676
  
        Auth: Restricted
        
  """
  phoneNumber: Int

  """
  The birthday of the user
  
        Auth: Restricted
  """
  birthday: DateTime

  """
  Tells if the user wants to show his age to other people or not
        
        Auth: Public
  """
  hideMyAge: Boolean

  """to validate or not his public activities"""
  isTrustedUserToCreateActivities: Boolean

  """to validate or not his public groups"""
  isTrustedUserToCreateCircles: Boolean

  """
  The sex of the user (MALE or FEMALE)
  
        Auth: Public
        
  """
  sex: Sex!

  """The address of a user"""
  address: AddressModel

  """The address of a user"""
  publicAddress: AddressModel

  """The list of all venues that current user owns"""
  venues(
    after: String
    first: Int
    before: String
    last: Int

    """Description of a filter in Sportunity"""
    filter: Filter
  ): VenueConnection

  """The list of sport descriptor of a user"""
  sports: [SportDescriptor]

  """Get the feedbacks for the given object"""
  feedbacks: Feedbacks

  """The list of all circles belonging to a given object"""
  circles(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection

  """The list of circles the current user is in"""
  circlesUserIsIn(
    """Get only circles with membership applied to it"""
    circlesWithFeesOnly: Boolean
    after: String
    first: Int
    before: String
    last: Int

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection

  """The list of circles subaccounts of the current user own"""
  circlesSuperUser(
    after: String
    first: Int
    before: String
    last: Int

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection

  """
  The list of circles from the club (only if current user is a team from a club)
  """
  circlesFromClub(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection

  """The list of all members from all the current user's circles"""
  allCircleMembers: [CircleMemberOutput]

  """The list of forms for personal information asked for circles"""
  circleInformationForms: [CircleInformationFormOutput]

  """The list of payment models for circles"""
  circlePaymentModels: [CirclePaymentModel]

  """Number of forms the user should fill"""
  numberOfFormsToFill: Int

  """Number of payment models the user should pay"""
  numberOfPaymentModelsToPay: Int

  """Get the documents of a user"""
  documents: [DocumentObject]

  """The list of all Sportunities"""
  sportunities(
    after: String
    first: Int
    before: String
    last: Int

    """Description of a filter in Sportunity"""
    filter: Filter

    """ID of the user we want to chat with"""
    userId: String

    """ID of the sportunity wanted"""
    id: String
    orderBy: Sportunities_Order
  ): SportunityConnection

  """The number of sportunities the user organized and booked in the past"""
  sportunityNumber: Int

  """The list of all chats of the user"""
  chats(
    after: String
    first: Int
    before: String
    last: Int

    """ID of the chat wanted"""
    id: ID
  ): ChatConnection

  """Tells if the user has a validated email address"""
  isEmailValidated: Boolean

  """Get the number of unread chats for current User"""
  unreadChats: Int
  mangoId: String

  """Fees to apply to user if he organizes a sportunity (20% -> 20)"""
  fees: Int

  """Fees to apply to user if he creates a payment model (3% -> 3)"""
  paymentModelFees: Int

  """Get the list of users that reported current user"""
  reporters: [ReporterUser]

  """Date of user's creation"""
  creation_date: DateTime
  creation_status: UserCreationStatus

  """The list of all notifications sent to this entity"""
  notifications(after: String, first: Int, before: String, last: Int): NotificationConnection

  """List payment methods for current user"""
  paymentMethods: [PaymentMethod]

  """The bank account registred for current user"""
  bankAccount: BankAccount

  """Get the number of unread chats for current User"""
  savedFilters: [UserFilter]

  """Get the number of unread chats for current User"""
  defaultSavedFilter: UserFilter

  """Tells if the basic filters have been created"""
  basicSavedFiltersCreated: Boolean

  """Tells if the basic circle filters have been created"""
  basicCircleSavedFiltersCreated: Boolean

  """Get the saved circle filters"""
  savedCircleFilters: [UserCircleFilter]

  """Get the default circle filter"""
  defaultSavedCircleFilter: UserCircleFilter

  """
  
          Last time the user get connected
        
  """
  lastConnexionDate: DateTime

  """The type of user"""
  profileType: UserProfileType

  """The users nationality"""
  nationality: String

  """User's occupation, ie. Work"""
  occupation: String

  """
  Could be only one of these values: 
            1 - for incomes <18K), 
            2 - for incomes between 18 and 30K, 
            3 - for incomes between 30 and 50K, 
            4 - for incomes between 50 and 80K, 
            5 - for incomes between 80 and 120K, 
            6 - for incomes >120K
  """
  incomeRange: Int

  """If the user is a business, then those fields are needed"""
  business: Business

  """Tells if the user has to declare VAT"""
  shouldDeclareVAT: Boolean

  """Return a bunch of Users for a given array of id"""
  subAccounts: [User]

  """Return a master account"""
  masterAccount: User
  authorized_managers: [AuthorizedManager]

  """Tells if current user is already a subaccount"""
  isSubAccount: Boolean
  calendar: Calendar

  """The list of all Sportunity templates for current user"""
  sportunityTemplates: [SportunityTemplate]

  """Gives the number of unread notifications for current user"""
  numberOfUnreadNotifications: Int
  notification_preferences: NotificationPreferences

  """Let the user choose if he wants to receive emails"""
  email_preferences: EmailPreferences

  """Tells if the current user has activated his statistics module"""
  areStatisticsActivated: Boolean

  """
  Tells if the user activated the availability statistics for his participants
  """
  areAvailabilityStatisticsActivated: Boolean

  """Tells if the user activated the terms of use for his circles"""
  areTermsOfUseActivated: Boolean

  """Returns the ToU for a specified user"""
  termsOfUses: [CircleTermsOfUse]

  """Tells if the user activated his compositions module"""
  areCompositionsActivated: Boolean

  """Get the Compositions of a user / event"""
  compositions: [CompositionOutput]

  """Get the statistic preferences for current User"""
  statisticPreferences(
    """ID of the user"""
    userID: String
  ): StatisticPreferences

  """Get the statistic filters of a user"""
  statisticFilters: [StatisticFilter]

  """Get the default statistic filter of a user"""
  defaultStatisticFilter: StatisticFilter

  """Returns the statistics for a specified user"""
  userStatistics: UserStatistics

  """Prefered home page"""
  homePagePreference: HomePagePreference

  """Tells if the current user can manage a venue"""
  userCanManageVenue: Boolean

  """Tells if the current user can test some specific features"""
  beta_tester: BetaTester

  """The user preferences"""
  userPreferences: UserPreferences

  """Tells if the user can query sportunityType filter"""
  canQuerySportunityTypeFilter: Boolean

  """Tells which tutorial steps are done by the user"""
  tutorialSteps: TutorialSteps
}

"""
For each user, gives the list of sportunity status the user want to synchronize
"""
type User_Status {
  """Return a Users for a given id"""
  user: User

  """Array of status of sportunities"""
  statuses: [SportunityStatus]
}

input userAddsDocumentInput {
  """Name of the document"""
  name: String
  clientMutationId: String
}

type userAddsDocumentPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

"""Represent a user's preference for his participant's availability"""
input UserAvailabilityStatsPrefsInput {
  """1st stat"""
  stat1: String

  """2nd stat"""
  stat2: String

  """3rd stat"""
  stat3: String

  """4th stat"""
  stat4: String

  """5th stat"""
  stat5: String
}

input userBooksEventInput {
  """The ID of the sportunity to book"""
  sportunityID: String!

  """The ID of the user which books"""
  participantID: String!

  """The ID of the payment method"""
  paymentMethodId: String

  """If the user pays with the wallet"""
  paymentByWallet: Boolean
  clientMutationId: String
}

type userBooksEventPayload {
  viewer: Viewer
  edge: SportunityEdge
  sportunity: Sportunity

  """URL sent by MangoPay to use 3D Secure"""
  secure3DURL: String
  clientMutationId: String
}

"""The filters that a user saved for circles"""
type UserCircleFilter {
  """The ID of an object"""
  id: ID!

  """The name of the filter"""
  filterName: String

  """Tells if the filter can be deleted"""
  canBeDeleted: Boolean
  location: CircleFilterLatLng
  sport: [CircleFilterSport]

  """Circle type"""
  circleType: [CircleListTypeEnum]

  """The type of the members"""
  memberType: CircleTypeEnum

  """Types of members (adults, children, ...)"""
  memberTypes: [CircleTypeEnum]

  """The kind of Circle"""
  modes: [CircleKind]

  """Return a bunch of Users for a given array of id"""
  owners: [User]

  """Is circle usable by member"""
  isCircleUsableByMember: Boolean

  """Position of the filter in the list"""
  position: Int
}

"""A connection to a list of items."""
type UserConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [UserEdge]

  """Total number of tags"""
  count: Int
}

"""Creation status of this user"""
type UserCreationStatus {
  """The status of current user"""
  status: userStatus

  """Tells the reason of the current status"""
  reason: String
}

"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge"""
  node: User

  """A cursor for use in pagination"""
  cursor: String!
}

"""The filters that a user saved"""
type UserFilter {
  """The ID of an object"""
  id: ID!

  """The name of the filter"""
  filterName: String

  """Tells if this filter can be deleted or not"""
  canBeDeleted: Boolean
  location: FilterLatLng
  sport: [FilterSport]

  """Return a price: NumberInterval"""
  price: IntInterval

  """Return a dates: StringInterval"""
  dates: StringInterval

  """Return a hours: NumberInterval"""
  hours: IntInterval

  """Status of sportunities"""
  status: SportunityStatus

  """Array of status of sportunities"""
  statuses: [SportunityStatus]

  """Page this filter is for"""
  page: HomePagePreference

  """Return a bunch of Users for a given array of id"""
  subAccounts: [User]

  """Get the available types of events for a sport"""
  sportunityTypes(
    """Sport type to get the event types possible"""
    sportType: SportTypeEnum
  ): [SportunityType]

  """The list of all circles belonging to a given object"""
  circles(
    after: String
    first: Int
    before: String
    last: Int

    """Types of wanted circles"""
    type: [CircleTypeEnum]

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection

  """Return a bunch of Users for a given array of id"""
  users: [User]

  """Position of the filter in the list"""
  position: Int
}

"""Save a filter"""
input UserFilterInput {
  """Id of the filter"""
  userFilterId: String

  """Name of the filter"""
  filterName: String

  """Tells if this filter can be deleted or not"""
  canBeDeleted: Boolean

  """Filter by location constraint"""
  location: LocationConstraint

  """Filter by sport name and level constraint"""
  sport: [SportConstraint]

  """The interval of price to filter"""
  price: IntIntervalInput

  """The interval of dates to filter"""
  dates: StringIntervalInput

  """The interval of hours of the beginning hours to filter"""
  hours: IntIntervalInput

  """Status of sportunities"""
  status: SportunityStatus

  """Array of status of sportunities"""
  statuses: [SportunityStatus]

  """Tells the page where this filter can be applied to"""
  page: HomePagePreference

  """ID of the sub-accounts to get their sportunities"""
  subAccounts: [String]

  """ID of the circles to get their sportunities"""
  circles: [String]

  """List of IDs of sportunity types to filter"""
  sportunityTypes: [String]

  """ID of the users to get their sportunities"""
  users: [String]

  """The position of this filter in the list"""
  position: Int
}

"""Represents a user input type"""
input UserInput {
  """First name of the user"""
  firstName: String

  """Last name of the user"""
  lastName: String

  """The unique pseudo of the user"""
  pseudo: String!

  """The unique email of the user"""
  email: Email

  """The password of the user"""
  password: String

  """List of language ids spoken by the current user"""
  languages: [String]

  """The language of user's app"""
  appLanguage: SupportedLanguage

  """The country of the user"""
  appCountry: supportedCountries

  """The currency of the user"""
  appCurrency: Currency

  """Description of the user"""
  description: String

  """The avatar url ot the user"""
  avatar: String

  """The phone prefix of the user"""
  phonePrefix: Int

  """The phone number of the user"""
  phoneNumber: Int

  """Birthday of the user"""
  birthday: String

  """The gender of the user"""
  sex: Sex!

  """Address of the user"""
  address: AddressInput

  """Fees to apply to user if he organizes a sportunity (20% -> 20)"""
  fees: Int

  """Fees to apply to user if he creates a payment model (3% -> 3)"""
  paymentModelFees: Int

  """List of sports that the user plays"""
  sports: [SportDescriptorInput]

  """The type of user"""
  profileType: UserProfileType

  """List of subaccounts pseudos"""
  subAccountsPseudoList: [String]
}

"""The user preferences"""
type UserPreferences {
  """Allow the user to create sub-accounts if activated"""
  areSubAccountsActivated: Boolean
}

"""The user preferences"""
input UserPreferencesInput {
  """Allow the user to create sub-accounts if activated"""
  areSubAccountsActivated: Boolean
}

"""Status of an event, for the current user"""
enum UserProfileType {
  """Natural user"""
  PERSON

  """Business user"""
  BUSINESS

  """Organization user"""
  ORGANIZATION

  """Soletrader user"""
  SOLETRADER
}

input userRemoveDocumentInput {
  documentId: String!
  clientMutationId: String
}

type userRemoveDocumentPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

"""User statistics object"""
type UserStatistics {
  """Gives the number of activities user participated"""
  numberOfParticipated: Int

  """Gives the number of activities user participated in a week"""
  averageNumberOfParticipatedWeek: Float

  """Gives the number of activities user participated in a month"""
  averageNumberOfParticipatedMonth: Float

  """Gives the number of activities user participated in a year"""
  averageNumberOfParticipatedYear: Float

  """Gives the number of activities user organized in a week"""
  averageNumberOfOrganizedWeek: Float

  """Gives the number of activities user organized in a month"""
  averageNumberOfOrganizedMonth: Float

  """Gives the number of activities user organized in a year"""
  averageNumberOfOrganizedYear: Float

  """
  Gives the percentage of organized activites versus booked activities (max 100)
  """
  percentageOfOrganized: Float

  """Gives the note of behavior - very bad : 0, very good : 4"""
  globalNote: Int

  """Return a averageTime: TranslatedString"""
  averageTime: TranslatedString
  steps: [UserStatisticsSteps]

  """Tells if the user has been participating / cancelling"""
  hasData: Boolean
  membersUserParticipatesWith: [MembersUserParticipatesWith]
}

"""The number of booking / canceling for each step"""
type UserStatisticsSteps {
  """Return a step: TranslatedString"""
  step: TranslatedString

  """The number of booking / canceling during the time interval"""
  value: Int
}

"""Represent a user's preference for his participant's stats"""
type userStats {
  """Get the current statistic"""
  stat0: StatisticName

  """Get the current statistic"""
  stat1: StatisticName

  """Get the current statistic"""
  stat2: StatisticName

  """Get the current statistic"""
  stat3: StatisticName

  """Get the current statistic"""
  stat4: StatisticName

  """Get the current statistic"""
  stat5: StatisticName

  """Get the current statistic"""
  statManOfTheGame: StatisticName
}

"""Represent a user's preference for his participant's stats"""
input UserStatsPrefsInput {
  """1st stat"""
  stat1: String

  """2nd stat"""
  stat2: String

  """3rd stat"""
  stat3: String

  """4th stat"""
  stat4: String

  """5th stat"""
  stat5: String
}

"""List of available status for a user"""
enum userStatus {
  """Can access to all functionnalities of the app"""
  VALID

  """A suspended user can't login"""
  SUSPENDED

  """A deleted user can't login"""
  DELETED
}

"""Represents a user status input type"""
input UserStatusInput {
  """The current status of the user"""
  status: userStatus

  """The reason of current status"""
  reason: String
}

input validateUserInput {
  """The ID of the user to update"""
  userID: String

  """A User input type"""
  user: UpdateUserInput
  clientMutationId: String
}

type validateUserPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

"""List of creation status for a sportunity or an event"""
enum ValidationStatus {
  """Waiting to be verificated by an admin (old)"""
  PENDING

  """Venue or sportunity has been validated by an admin"""
  VALIDATED

  """
  Venue or sportunity has been rejected by an admin : users won't see it
  """
  REJECTED

  """Waiting to be verificated by an admin (new)"""
  TO_BE_VALIDATED
}

"""A venue for a Sportunity"""
type Venue implements Node {
  """The ID of an object"""
  id: ID!

  """The name of the Venue"""
  name: String!

  """The full description of the Venue"""
  description: String!

  """The address of a user"""
  address: AddressModel

  """Return a Users for a given id"""
  owner: User

  """Get the feedbacks for the given object"""
  feedbacks: Feedbacks

  """The Infrastructures of a given object"""
  infrastructures(
    """Description of a filter in Sportunity"""
    filter: Filter
  ): [Infrastructure]

  """Logo of the venue"""
  logo: String

  """Get the Prices of an object"""
  price: Price
  creation_status: VenueCreationStatus
}

"""A connection to a list of items."""
type VenueConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [VenueEdge]

  """Total number of tags"""
  count: Int
}

"""Creation status of this venue"""
type VenueCreationStatus {
  """The status of current venue"""
  status: ValidationStatus

  """Tells the reason of the current status"""
  reason: String
}

"""An edge in a connection."""
type VenueEdge {
  """The item at the end of the edge"""
  node: Venue

  """A cursor for use in pagination"""
  cursor: String!
}

"""Represents a venue input type"""
input VenueInput {
  """Name of the venue"""
  name: String!

  """Description of the venue"""
  description: String!

  """Address id of the venue"""
  address: AddressInput!

  """Owner id of the venue"""
  owner: String

  """Feedbacks on the venue"""
  feedbacks: [FeedbackInput]

  """Logo of the venue"""
  logo: String

  """The price to create a sportunity in this venue"""
  price: PriceInput
}

"""Represents a venue status input type"""
input VenueStatusInput {
  """The current status of the venue"""
  status: ValidationStatus

  """The reason of current status"""
  reason: String
}

"""Represents a venue update input type"""
input VenueUpdateInput {
  """Name of the venue"""
  name: String

  """Description of the venue"""
  description: String

  """Address id of the venue"""
  address: AddressInput

  """Owner id of the venue"""
  owner: String

  """Feedbacks on the venue"""
  feedbacks: [FeedbackInput]

  """Infrastructures of the venue"""
  infrastructures: [InfrastructureInput]

  """Logo of the venue"""
  logo: String

  """The price to create a sportunity in this venue"""
  price: PriceInput

  """The status of current venue"""
  creation_status: VenueStatusInput
}

"""Represents the viewer"""
type Viewer implements Node {
  """The viewer Id"""
  id: ID!

  """Get a sport for object that have only one"""
  sport(
    """ID of the sport wanted"""
    id: ID
  ): Sport

  """The list of all sports on the platform"""
  sports(
    after: String
    first: Int
    before: String
    last: Int

    """Description of a filter in Sport"""
    filter: SportFilter

    """IDs of the sports wanted"""
    ids: [String]

    """Language of the sport's name (to sort them)"""
    language: SupportedLanguage
  ): SportConnection

  """Get the available types of events for a sport"""
  sportunityTypes(
    """Sport type to get the event types possible"""
    sportType: SportTypeEnum
  ): [SportunityType]

  """Return a User for a given id"""
  user(
    """The id of the object you want to retrieve"""
    id: String!
  ): User

  """Return the currently logged in user"""
  me: User

  """The list of all users on the platform"""
  users(
    """Used to get users pseudo autocompletion"""
    pseudo: String

    """Used to search users by email"""
    email: String

    """Used to search users by profile type"""
    userType: UserProfileType

    """Search only parents"""
    parentsOnly: Boolean

    """Search only children"""
    childrenOnly: Boolean

    """List of user ids to get"""
    ids: [String]

    """Filter by sport name and level constraint"""
    sport: [SportConstraint]
    after: String
    first: Int
    before: String
    last: Int
  ): UserConnection

  """Check if a user exists, given his pseudo or email"""
  userExists(
    """Pseudo of the user to check"""
    pseudo: String

    """Email of the user to check"""
    email: String

    """Used to search users by profile type"""
    userType: UserProfileType

    """Tells if this query is done for registration steps or not"""
    registration: Boolean
  ): Boolean

  """The list of all assistants for a specific sport / assistant type"""
  assistants(
    """Sport requested"""
    sportId: String!

    """Assistant type requested"""
    assistantTypeId: String
    after: String
    first: Int
    before: String
    last: Int
  ): UserConnection

  """Returns superUser information with the token sent"""
  superMe(
    """Token of the user logged in"""
    superToken: String
  ): SuperUser

  """Returns accounts that current user can connect to"""
  authorizedAccounts(
    """Token of the user logged in"""
    userToken: String
  ): AuthorizedAccounts

  """A circle"""
  circle(
    """ID of the circle wanted"""
    id: ID

    """Code to invit a member or a circle in a private circle"""
    code: String
  ): Circle

  """The list of all public circles"""
  circles(
    after: String
    first: Int
    before: String
    last: Int

    """Description of a filter in Sportunity"""
    filter: CirclesFilter
  ): CircleConnection

  """User personal reference for payment models"""
  circlePersonalReference(
    """Id of the circle"""
    circleId: String!
  ): String

  """Return the list of languages"""
  languages: [Language]

  """Get all languages supported by the app"""
  supportedLanguages: [String]

  """A Sportunity"""
  sportunity(
    """ID of the sportunity wanted"""
    id: ID

    """External reference"""
    externalReference: String
  ): Sportunity

  """The list of all Sportunities"""
  sportunities(
    after: String
    first: Int
    before: String
    last: Int

    """Description of a filter in Sportunity"""
    filter: Filter

    """ID of the user we want to chat with"""
    userId: String

    """ID of the sportunity wanted"""
    id: String
    orderBy: Sportunities_Order
  ): SportunityConnection

  """The list of all organizers of sportunities"""
  sportunitiesOrganizers(
    after: String
    first: Int
    before: String
    last: Int

    """Description of a filter in Sportunity"""
    filter: Filter

    """ID of the user we want to chat with"""
    userId: String

    """ID of the sportunity wanted"""
    id: String
    orderBy: SportunitiesOrganizers_Order
  ): UserConnection

  """Get the status of the sportunity for current User"""
  sportunityStatus(
    """ID of the sportunity wanted"""
    sportunityId: String

    """ID of the user to get his status"""
    userId: String
  ): String

  """The list of all opponent for a specific sport"""
  opponents(
    """Used to get users pseudo autocompletion"""
    pseudo: String

    """Sport requested"""
    sportId: String
    after: String
    first: Int
    before: String
    last: Int
  ): UserConnection

  """The list of all my opponents for a specific sport"""
  myOpponents(
    """Used to get users pseudo autocompletion"""
    pseudo: String

    """Sport requested"""
    sportId: String
    after: String
    first: Int
    before: String
    last: Int
  ): UserConnection

  """Get a venue for object that have only one"""
  venue(
    """ID of the sportunity wanted"""
    id: ID
  ): Venue

  """The list of all venues on Sportunity"""
  venues(
    after: String
    first: Int
    before: String
    last: Int

    """Description of a filter in Sportunity"""
    filter: Filter
  ): VenueConnection

  """Get the infrastructure of an object"""
  infrastructure(
    """ID of the infrastructure wanted"""
    id: ID
  ): Infrastructure

  """The Infrastructures of a given object"""
  infrastructures(
    """Description of a filter in Sportunity"""
    filter: Filter
  ): [Infrastructure]

  """The a list slots"""
  slots(
    """ID of the infrastructure we want the avaialbe slots of"""
    id: ID

    """ID of the sportunity user is updating"""
    updatingSportunity: ID

    """Description of a filter in Sportunity"""
    filter: Filter
  ): [Slot]

  """The list of all messages in a discussion"""
  chat(
    after: String
    first: Int
    before: String
    last: Int

    """ID of the chat"""
    id: String

    """ID of the user we want to chat with"""
    userId: String

    """ID of the sportunity"""
    sportunityId: String

    """ID of the circle"""
    circleId: String
  ): Chat

  """The list of all chats of the user"""
  chats(
    after: String
    first: Int
    before: String
    last: Int

    """ID of the chat wanted"""
    id: ID
  ): ChatConnection

  """Ask Mango Pay to register a new card"""
  cardRegistration: cardRegistration

  """Ask Mango Pay to register a bank wire"""
  bankwireToWallet(
    """The amount the user wants to cash in"""
    amount: PriceInput!
  ): BankWireToWallet

  """Ask Mango Pay to get the amount on current user's wallet"""
  amountOnWallet: AmountOnWallet

  """Request an invoice for a specific user & sportunity"""
  requestInvoice(
    """Id of the sportunity"""
    sportunityID: String!
  ): Boolean

  """Sends a new mail to users that are invited to a sportunity"""
  relaunchInviteds(
    """ID of the sportunity"""
    sportunityID: String!
  ): Sportunity

  """Get the statistic preferences for current User"""
  statisticPreferences(
    """ID of the user"""
    userID: String
  ): StatisticPreferences

  """Get the statistics for a sportunity"""
  sportunityStatistics(
    """ID of the sportunity"""
    sportunityID: String
  ): [Statistic]

  """Get the statistics for a user"""
  circlesStatistics(
    """ID of the user"""
    userID: String

    """ID of the circle"""
    circleID: String

    """Stats on multiple circle"""
    circlesIDs: [String]

    """The interval of dates to filter"""
    dateInterval: StringIntervalInput

    """Type of the sportunities wanted (match, training, ...)"""
    eventType: String
  ): [CirclesStatisticsOrganizer]

  """A payment model"""
  circlePaymentModel(
    """ID of the payment model wanted"""
    paymentModelId: ID
  ): CirclePaymentModel

  """Get the statistics for a user"""
  sportunitiesStatistics(
    """ID of the user"""
    userID: String
  ): [SportunitiesStatisticsOrganizer]

  """Global statistics for the application"""
  AdminStatistics: AdminStatistics

  """Tells if current user is co-organizer on a serie or not"""
  IsCoOrganizerOnSerie(
    """Id of the sportunity"""
    sportunityId: String!
  ): Boolean

  """Returns a Composition for a given id"""
  composition(
    """The id of the object you want to retrieve"""
    id: String!
  ): CompositionOutput

  """The list of owners of circles the current user is in"""
  ownersOfCirclesUserIsIn(after: String, first: Int, before: String, last: Int): UserConnection

  """Get the content of a short url"""
  url(
    """Short url to convert to long one"""
    shortUrl: String
  ): String

  """Create a short url from a long one"""
  createShortUrl(
    """Long url to convert"""
    url: String!
  ): String

  """Get the list of transactions for the current user"""
  transactions(after: String, first: Int, before: String, last: Int, filter: TransactionFilter): TransactionConnection
}

input voteForManOfTheGameInput {
  """ID of the sportunity"""
  sportunityID: String!

  """ID of the participant current user is voting for"""
  participantID: String!
  clientMutationId: String
}

type voteForManOfTheGamePayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}
